<!DOCTYPE html>
<html lang="de">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="style.css">
	<title>Kl√§nge f√ºr den Weltraum (PC Underground, PC Magazin 5/1999)</title>
</head>
<body>
	<div class="credits">
		<h2>Dieser Artikel erschien erstmals im PC&nbsp;Magazin&nbsp;5/1999. Die Wieder&shy;ver√∂ffentlichung erfolgt mit freundlicher Genehmigung der <a rel="external nofollow noreferrer" href="https://www.weka-media-publishing.de">WEKA&nbsp;Media&nbsp;Publishing&nbsp;GmbH</a>.</h2>
	</div>

	<nav class="pagenav">
		<a rel="prev" href="199904.html">4/1999</a>
		<a href="index.html">Inhalt</a>
		<a rel="next" href="199906.html">6/1999</a>
	</nav>

	<article>
	<header>
		<h2>Spiele-Programmierung unter Windows 95/98/NT</h2>
		<h1>Kl√§nge f√ºr den <span class="highlight">Weltraum</span></h1>
		<p class="summary">F√ºr ein Weltraum-Ballerspiel kapseln Sie <span class="highlight">DirectSound-Aufrufe</span> in einer eigenen Klasse und synthetisieren Soundeffekte.</p>
	</header>

	<section>
		<h3>Carsten Dachsbacher/Nils Pipenbrinck</h3>
		<p>Das Interesse vieler Computerfreaks an Science Fiction erkl√§rt die Existenz unz√§hliger Weltraumspiele f√ºr den PC. Sie m√ºssen weder ein Freak sein noch jede Folge Raumschiff Enterprise auswendig kennen, um mit uns in den n√§chsten drei Ausgaben des <i>PC Magazin</i> ein kleines Weltraumspiel f√ºr Windows zu schreiben. Als Vorlage dient der Klassiker <i>Gravity Wars</i>, wie es ihn fr√ºher auf Videospiel&shy;automaten oder f√ºr PCs mit Hercules- und CGA-Karte gab.</p>
		<p>Bei diesem Spiel steuern zwei Spieler je einen Raumgleiter √ºber ein zwei&shy;dimensionales Spielfeld, das den Weltraum darstellt. Die Gleiter lassen sich drehen, beschleunigen und wieder abbremsen. Au√üerdem stehen jedem Spieler eine Laserkanone sowie Raketen zur Verf√ºgung, mit denen er versucht, den Gegner abzuschie√üen (das alles ist nat√ºrlich nur ein Spiel, und die Raketen sind mit harmlosem Joghurt gef√ºllt).</p>
		<p>Jeder Raumgleiter verf√ºgt √ºber Energie, die der Spieler auf die Waffen- und Schildsysteme verteilt. Optional k√∂nnen Sie in der Mitte des Spielfelds noch einen Planeten plazieren, der alle Objekte wie Raumgleiter und Raketen anzieht (daher der Name <i>Gravity Wars</i>). Je nach Lust und Laune sind zus√§tzliche Erweiterungen denkbar ‚Äì einige werden Sie in den n√§chsten Ausgaben von PC Underground realisieren.</p>
		<p>In diesem ersten Teil legen Sie den Grundstein f√ºr Ihr eigenes Spiel. Damit es die richtige Atmosph√§re bietet, brauchen Sie schnelle, fl√ºssige Grafikroutinen, ansprechende Soundeffekte und eine vern√ºnftige Steuerung.</p>
	</section>

	<aside>
		<h2>QUELLTEXTE</h2>
		<div>Die Quelltexte zu diesem Artikel finden Sie in der Datei  <a href="199905.zip">üíæ 199905.zip</a>.</div>
	</aside>

	<section>
		<h2>Die Grafik&shy;bibliothek</h2>
		<p>Als Grafik&shy;bibliothek verwenden Sie am besten eine modifizierte Version der Demobibliothek, die bereits allen fr√ºheren Programmen in dieser Rubrik als Grundlage diente. Doch keine Angst: Sie m√ºssen jetzt keine alten Ausgaben des <i>PC Magazin</i> durchst√∂bern, um sich die Routinen des Grafiksystems wieder in Erinnerung zu rufen:</p>
		<p>In der Textbox ‚ÄûFunktionen der Grafik&shy;bibliothek‚Äú auf S. 229 stellen wir Ihnen alle Funktionen der Bibliothek noch einmal vor. Dieses leicht erneuerte Basissystem finden Sie komplett mit allen Quellcodes auf der Heft-CD in der selbst&shy;entpackenden Archiv-Datei <i>Basissystem.exe</i> und auf der Homepage des <i>PC Magazin</i></p>
		<p>Der Einsatz in einem Spiel verlangte einige √Ñnderungen an den bisherigen Routinen: Um Zugriff auf die Tastatur zu erhalten, f√§ngt die Hauptschleife des Programms jetzt die Window-Messages der Tastatur ab. Der aktuelle Zustand der Tasten wird im Array <i>KeyState</i> gespeichert. In Ihren Anwendungen lesen Sie damit die Zust√§nde der einzelnen Tasten aus.</p>
		<p>Bitte beachten Sie, da√ü Ihr Programm nicht mehr automatisch bei jedem Tastendruck beendet wird. Ob die <i>[Esc]</i> oder Leertaste gedr√ºckt wurde, √ºberpr√ºfen Sie jetzt selbst. Die Hauptschleife Ihrer Demo bzw. Ihres Spiels sieht damit wie folgt aus:</p>
		<pre><code>
void demomain (void)
{
	short* bild = new short[SCREEN_X * SCREEN_Y];

	while((DemoRunning) &amp;&amp;
		(!KeyState[VK_ESCAPE]))
	{
		/* hier zeichnen Sie was */
		...

		BlitGraphic(bild);
	}

	delete bild;
}
		</code></pre>
	</section>

	<section>
		<h2>Grundlagen von DirectSound</h2>
		<p>Mit DirectSound w√§hlen Sie einen modernen Weg, um einfach Soundeffekte unter Windows abzuspielen. Die DirectSound-API ist ein Bestandteil von DirectX. Haben Sie noch keine Erfahrung mit DirectX, ist dies gar kein Problem: Im Gegensatz zu DirectDraw ist die Sound&shy;programmierung erfreulich einfach.</p>
		<figure class="floatright">
			<img src="assets/199905_2.png" width="302" height="509" alt="WAV-DATEIEN ENTHALTEN je einen Format- und einen Daten-Chunk.">
			<figcaption><span>WAV-DATEIEN ENTHALTEN</span> je einen Format- und einen Daten-Chunk.</figcaption>
		</figure>
		<p>Um das Abspielen von Soundeffekten so einfach und angenehm wie m√∂glich zu gestalten, bauen Sie keine spezifischen Aufrufe von DirectSound in das Hauptprogramm ein. Statt dessen schreiben Sie eine C++-Klasse, die die genaue Implemen&shy;tierung versteckt.</p>
		<p>Diese Technik bietet einige Vorteile: Zum einen m√ºssen Sie sich bei der Spiele&shy;programmierung nicht mit den Systemaufrufen von DirectSound herumschlagen. Zum anderen k√∂nnen Sie eine gut durchdachte C++-Klasse auch in anderen Programmen wieder&shy;verwenden.</p>
		<p>Mit DirectSound k√∂nnen Sie ‚Äì im Gegensatz zum alten Multimedia-System ‚Äì mehrere Soundeffekte gleichzeitig abspielen. Au√üerdem besitzen Sie auch w√§hrend des Abspielens die volle Kontrolle √ºber Lautst√§rke, Frequenz und Position im Stereoraum des Samples. Um das zu verwirklichen, gingen die Programmierer von DirectSound einen ungew√∂hnlichen Weg.</p>
		<p>Nahezu alle herk√∂mmlichen Sound&shy;bibliotheken unter Windows benutzen das Konzept der Soundkan√§le. Bei der Initial&shy;isierung legen Sie fest, wie viele Kan√§le f√ºr das gleichzeitige Abspielen von Samples bereitstehen. Dabei ist es egal, ob alle Kan√§le einen Soundeffekt wiedergeben oder jeder Kanal einen anderen abspielt. Bei DirectSound sind Samples und Kan√§le direkt miteinander verbunden. Wenn Sie einen Kanal (im DirectSound-Jargon hei√üen diese <i>DirectSoundBuffer</i>) anlegen, kann dieser immer nur einen einzigen Soundeffekt abspielen.</p>
		<p>Das hat einige Folgen f√ºr Sie: Sie m√ºssen schon w√§hrend der Initial&shy;isierung des Soundsystems festlegen, wie viele Kan√§le Sie zum Beispiel f√ºr Schu√üger√§usche verwenden m√∂chten. Gl√ºcklicher&shy;weise ist DirectSound relativ intelligent. Soundeffekte, die nicht zu h√∂ren sind, brauchen zwar etwas Speicher, aber kaum Rechenzeit.</p>
		<p>DirectSound ist ein sehr m√§chtiges Werkzeug. Deshalb kann dieser Artikel auch nur die Oberfl√§che dessen betrachten, was alles mit DirectSound machbar ist. Bitte beachten Sie, da√ü wir aus Platzgr√ºnden die Abfrage von Fehlern in den Beispielcodes weggelassen haben.</p>
	</section>

	<section>
		<h2>DirectSound im Detail</h2>
		<p>Zun√§chst legen Sie ein <i>IDirectSound</i>-Objekt an. Damit steuern Sie sp√§ter die Soundkarte des PC:</p>
		<pre><code>
IDirectSound* DSound;
HWND FensterHandle;

DirectSoundCreate(NULL, &amp;DSound, 0);
DSound->SetCooperativeLevel(FensterHandle, DSSCL_EXCLUSIVE)
		</code></pre>
		<p><i>DirectSoundCreate</i> erzeugt das <i>IDirectSound</i>-Objekt. Durch den Aufruf von <i>SetCooperativeLevel</i> teilen Sie Windows mit, da√ü Sie von nun an direkten Zugriff auf die Soundkarte haben m√∂chten. Das ist zwar nicht unbedingt n√∂tig, aber Sie vermeiden so eine Menge √Ñrger. Programme, die im Hintergrund laufen und auch auf die Soundkarte zugreifen m√∂chten, werden nun allerdings blockiert und k√∂nnen nicht mehr auf Ressourcen der Soundkarte zugreifen.</p>
		<p>Fordern Sie einen Soundpuffer vom System an. Daf√ºr f√ºllen Sie ‚Äì wie es allgemein bei DirectX √ºblich ist ‚Äì einige Strukturen aus und definieren dabei genau, in welchem Format der Soundeffekt vorliegt. In diesem Beispiel erzeugen Sie ein zwei Sekunden langes 8-Bit Mono-Sample mit einer Sampling-Frequenz von 22050 Hertz:</p>
		<pre><code>
WAVEFORMATEX Format;
DSBUFFERDESC bd;
IDirectSoundBuffer Buffer;

// Strukturen l√∂schen
memset(&amp;Format, 0, sizeof (WAVEFORMATEX));
memset(&amp;bd, 0, sizeof (bd));

// Ben√∂tigte Felder ausf√ºllen
Format.wFormatTag = WAVE_FORMAT_PCM;
Format.nChannels = 1;
Format.nSamplesPerSec = 22050;
Format.nAvgBytesPerSec = 22050;
Format.nBlockAlign = 1;
Format.wBitsPerSample = 8;
bd.dwSize = sizeof (bd);
bd.dwFlags =
	DSBCAPS_CTRLDEFAULT |
	DSBCAPS_STATIC;
bd.dwBufferBytes = 44100;
bd.lpwfxFormat = &amp;Format;

// und den Buffer erstellen.
DSound->CreateSoundBuffer(&amp;bd, &amp;Buffer, NULL);
		</code></pre>
		<p>Interessant sind hier die Flags, die Sie im Feld <i>bd.dwFlags</i> √ºbergeben. Dort bestimmen Sie, welche F√§higkeiten von DirectSound Sie benutzen. In diesem Beispiel setzen Sie die Flags <i>CTRLDEFAULT</i> und <i>STATIC</i>.</p>
		<p><i>STATIC</i> sagt DirectSound, da√ü Sie den Soundeffekt nicht st√§ndig √§ndern m√∂chten. Dadurch kann DirectSound bei einigen Modellen die Sample-Daten direkt auf die Soundkarte √ºbertragen und dort von der Hardware abspielen lassen. Dies entlastet den Prozessor erheblich.</p>
		<p>Das <i>CTRLDEFAULT</i>-Flag besagt nur, da√ü Sie Frequenz, Lautst√§rke und die Stereoposition des Samples kontrollieren m√∂chten.</p>
		<p>Jetzt f√ºllen Sie den Puffer mit Sample-Daten. Dazu rufen Sie die Funktion <i>Lock</i> auf, die Ihnen einen Pointer auf den internen Speicher des Puffers zur√ºckgibt. Die Funktion <i>Lock</i> ist so programmiert, da√ü Sie auch Zugriff auf die Samples bekommen, wenn der Sound gerade abgespielt wird. Das ist ein n√ºtzliches Feature, aber f√ºr unsere Zwecke gar nicht n√∂tig.</p>
		<pre><code>
void *Ptr1;
void *Ptr2;
unsigned long Size1;
unsigned long Size2;

Buffer->Lock(0, 44100, &amp;Ptr1,
	&amp;Size1, &amp;Ptr2, &amp;Size2,0);
		</code></pre>
		<p>Die ersten beiden Parameter bezeichnen die Startposition und die Anzahl der Samples, auf die Sie Zugriff w√ºnschen. Oben fordern Sie also Zugriff auf das gesamte Sample an.</p>
		<p>Nachdem Sie die Funktion <i>Lock</i> aufgerufen haben, kopieren Sie Ihre Daten in den Speicher&shy;bereich, auf den <i>Ptr1</i> zeigt. Die beiden Variablen <i>Ptr2</i> und <i>Size2</i> brauchen Sie nur, wenn Sie einen Teil des Samples √§ndern m√∂chten. F√ºr unser Spiel ist dies aber nicht n√∂tig. Jetzt beginnen Sie bereits mit der Ausgabe:</p>
		<pre><code>
Buffer->Unlock(Ptr1, Size1, Ptr2, Size2);
Buffer->Play(0, 0, 0);
		</code></pre>
		<p>√úber den Aufruf von <i>Unlock</i> teilen Sie DirectSound mit, da√ü Sie mit dem Schreiben fertig sind. <i>Play</i> startet das Abspielen des Samples. Wenn alles geklappt hat, h√∂ren Sie jetzt Ihren Soundeffekt.</p>
	</section>

	<aside>
		<h2>FUNKTIONEN DER GRAFIKBIBLIOTHEK</h2>
		<div>
			<p>Um die Grafik&shy;bibliothek zu nutzen, implementieren Sie folgende drei Funktionen in Ihrem Programm:<br>
			‚Ä¢ In der Funktion <i>BOOL demoinit() { ... }</i> erledigen Sie alle nur einmal ben√∂tigten Initial&shy;isierungen. Sind diese alle gegl√ºckt, gibt die Funktion den Wert <i>true</i> zur√ºck. Hier belegen Sie auch die Variable <i>Fenster_Modus</i> mit dem gew√ºnschten Bildschirm&shy;modus (siehe Quellcode von <i>demosys.h</i>).<br>
			‚Ä¢ Innerhalb von <i>void demomain() { ... }</i> l√§uft Ihr Hauptprogramm wie in einer gew√∂hnlichen <i>main</i>-Funktion.<br>
			‚Ä¢ In der Funktion <i>void demoquit() { ... }</i> kann Ihr Programm die zum Programmende notwendigen Einzelschritte durchf√ºhren. Sodann nutzen Sie folgende Funktionen:<br>
			‚Ä¢ <i>void BlitGraphic(void *)</i> stellt den Inhalt des als Zeiger √ºbergebenen HighColor-Bildschirm&shy;puffers im Fenster oder im DirectX-Vollbildmodus dar. Im HighColor-Modus beansprucht jedes Pixel 16 Bit (5 f√ºr Rot, 6 f√ºr Gr√ºn und 5 f√ºr Blau).<br>
			‚Ä¢ <i>unsigned short ColorCode(r,g,b)</i> √ºbernimmt f√ºr Sie die Berechnung des HighColor-Farbwerts aus den RGB-Angaben. Liegen Rot, Gr√ºn und Blau jeweils im Bereich von <i>0</i> bis <i>255</i>, berechnen Sie aus Geschwindig&shy;keitsgr√ºnden den Farbwert wie folgt:</p>
			<pre><code>color = Rtab[R]|Gtab[G]|Btab[B];</code></pre>
			<p>‚Ä¢ <i>unsigned long GetDemoTime(void)</i> liefert Ihnen die seit dem Programmstart abgelaufene Zeit in Millisekunden.</p>
		</div>
	</aside>

	<section>
		<h2>Die Klasse SoundSystem</h2>
		<p>DirectSound ist zwar eine √ºbersichtliche API, bereitet dem Programmierer aber trotzdem viel Arbeit. Deshalb haben wir Ihnen ‚Äì wie bereits angek√ºndigt ‚Äì eine einfache Schnittstelle programmiert, mit der alles einfacher wird. Dieses sehr einfache Soundsystem finden Sie in den Dateien <i>soundsys.cpp</i> und <i>soundsys.h</i>. Ein kleines Beispiel zeigt die Anwendung:</p>
		<pre><code>
SoundSystem Sound;
int Sample1, int Sample2;

Sound.initialize
	(Program_Fenster);

// Boing.WAV + Peng!.WAV laden
// jeweils 10 Soundkan√§le f√ºr Samples vorbereiten
Sample1 = Sound.LoadSound(‚ÄúBoing.WAV‚Äú, 10);
Sample2 = Sound.LoadSound(‚ÄúPeng!.WAV‚Äú, 10);

// Zum Test Samples abspielen
Sound.PlaySound(Sample1);
Sound.PlaySound(Sample2);
		</code></pre>
		<p>Die Klasse <i>SoundSystem</i> k√ºmmert sich um die interne Verwaltung von Soundpuffern, das Laden von Samples und die Fehler&shy;behandlung von DirectSound.</p>
		<p>Bevor Sie jetzt loslegen und Ihre Nachbarn mit komischen Ger√§uschen unterhalten, noch ein Hinweis: Falls Sie einen anderen Compiler als Watcom C++ benutzen, f√ºgen Sie Ihrem Projekt bzw. Makefile unbedingt die Bibliotheks&shy;datei <i>dsound.lib</i> hinzu ‚Äì sonst klappt‚Äôs nicht mit dem Nachbarn. Das selbst&shy;entpackende <i>zip</i>-Archiv <i>SoundBeispiel.exe</i> enth√§lt ein kleines Demoprogramm, das ein Donnergrollen und ein kurzes Ploppen zeitgleich abspielt.</p>
	</section>

	<aside>
		<h2>GLOSSAR ZUR KLANGSYNTHESE</h2>
		<div>
			<table>
				<thead>
					<tr><th>Begriff</th><th>Bedeutung</th></tr>
				</thead>
				<tbody>
					<tr><td>ADSR</td><td>Abschnitte der H√ºllkurve<br>
						‚Ä¢ <i>Attack</i> = Anschlag<br>
						‚Ä¢ <i>Decay</i> = Verz√∂gerung nach dem Anschlag<br>
						‚Ä¢ <i>Sustain</i> = Haltezeit der Lautst√§rke nach dem Decay<br>
						‚Ä¢ <i>Release</i> = Abfallzeit der (Rest-)Lautst√§rke</td></tr>
					<tr><td>Filter</td><td>schw√§cht oder verst√§rkt bestimmte Frequenz&shy;anteile in einem Klang</td></tr>
					<tr><td>H√ºllkurve</td><td>Lautst√§rke&shy;verlauf f√ºr einen Oszillator</td></tr>
					<tr><td>Oszillator</td><td>Schwingkreis, der durch Spannungswerte eine bestimmte Wellenform erzeugt</td></tr>
					<tr><td>Phase</td><td>Position innerhalb einer Schwingungs&shy;periode eines Oszillators</td></tr>
					<tr><td>Wellenform</td><td>Art der Schwingung (zum Beispiel Sinus-, Rechteck- oder S√§gezahn&shy;schwingung)</td></tr>
				</tbody>
			</table>
		</div>
	</aside>

	<section>
		<h2>Aufbau einer <i>wav</i>-Datei</h2>
		<p>In der Windows-Welt sind <i>wav</i>-Dateien das Standardformat f√ºr Sounds. Deshalb ist es sinnvoll, dieses Format f√ºr das Soundsystem zu benutzen, auch wenn es nicht ganz einfach zu lesen ist. Das <i>wav</i> Format ist eine Unterform des <i>Resource Interchange File Format</i> (RIFF), welches Windows f√ºr die meisten Multimedia-Daten verwendet (neben Samples auch Bilder und Animationen).</p>
		<p>Eine RIFF-Datei setzt sich aus mehreren kleinen Datenbl√∂cken (sogenannten Chunks) zusammen. Den genauen Aufbau stellen Sie sich am besten wie eine Verzeichnis&shy;struktur vor: Jeder Chunk kann mehrere Unter-Chunks besitzen (vergleichbar mit Unter&shy;verzeichnissen) und auch Daten enthalten.</p>
		<p>Zur eindeutigen Identifikation tragen alle Chunks eine aus vier Buchstaben bestehende Kennung. Diese nutzen Sie, um Windows gezielt nach ben√∂tigten Daten-Chunks suchen zu lassen oder sich die Struktur eines unbekannten Dateityps anzusehen. Jede RIFF-Datei beginnt mit einem Chunk namens <i>RIFF</i>. Dieser Chunk enth√§lt keine Daten, sondern nur Unter-Chunks. Er ist sozusagen das Haupt&shy;verzeichnis der RIFF-Datei. F√ºr das <i>wav</i> Format sind die Unter-Chunks genau definiert (siehe Bild S. 228).</p>
		<p>Der erste ist der Format-Chunk mit der Kennung <i>fmt</i>. Dort gibt eine <i>WAVEFORMATEX</i>-Struktur genaue Auskunft √ºber das Sample-Format. Sie informiert unter anderem √ºber die Anzahl der verwendeten Kan√§le (Mono oder Stereo), die Abtastrate und Bit-Tiefe:</p>
		<pre><code>
struct WAVEFORMATEX
{
	WORD wFormatTag;
	WORD nChannels;
	DWORD nSamplesPerSec;
	DWORD nAvgBytesPerSec;
	WORD nBlockAlign;
	WORD wBitsPerSample;
	WORD cbSize;
};
		</code></pre>
		<p>Die Felder <i>nAvgBytesPerSec</i> und <i>nBlockAlign</i> benutzt Windows, um komprimierte Dateien abzuspielen. Da Sie unter DirectSound lediglich unkomprimierte Samples verwenden, k√∂nnen Sie diese Felder getrost ignorieren.</p>
		<p>Direkt auf den Format-Chunk folgt der Daten-Chunk namens <i>data</i>. Er enth√§lt die rohen Sample-Daten. Eine hervorragende √úbersicht √ºber den Aufbau ver&shy;schiedenster Dateiformate erhalten Sie ‚Äì wenn auch in englischer Sprache ‚Äì auf der Web-Seite <a href="https://www.wotsit.org" rel="external nofollow noreferrer">www.wotsit.org</a></p>
	</section>

	<section>
		<h2>Die Multimedia IO-Funktionen</h2>
		<p>Die Ein- und Ausgabe (IO = Input/Output) bei Multimedia-Dateien entspricht weitestgehend dem Umgang mit gew√∂hnlichen Dateien. Nachdem Sie eine Multimedia-Datei ge√∂ffnet haben, lassen Sie Windows den RIFF-Chunk suchen. Zwar steht dieser Chunk in der Regel am Anfang der Datei, aber es gibt auch einige wenige RIFF-Dateien, die davor noch zus√§tzliche Informationen bereithalten.</p>
		<p>Rufen Sie zum Suchen die Funktion <i>mmioDescend</i> auf, die dem Wechseln in ein Unter&shy;verzeichnis entspricht. Nun sind Sie im Haupt-Chunk der <i>wav</i>-Datei. Von hier aus k√∂nnen Sie durch erneuten Einsatz von <i>mmioDescend</i> den Format- und Daten-Chunk suchen und lesen.</p>
		<p>Um in den √ºbergeordneten Chunk zur√ºck&shy;zuwechseln, rufen Sie die Funktion <i>mmioAscend</i> auf. Im DOS-Dateisystem entspr√§che dieser Befehl dem Kommando</p>
		<pre><code>cd..</code></pre>
		<p>Das folgende Beispiel-Listing enth√§lt aus Platzgr√ºnden keine Fehlerabfragen. F√ºr einen sauberen Programmier&shy;stil sollten Sie dies aber auf keinen Fall vers√§umen. Eine leicht zu benutzende C++-Klasse zu <i>wav</i>-Dateien finden Sie in den Dateien <i>LoadWav.cpp</i> und <i>LoadWav.h</i>. Dort haben wir f√ºr Sie die Multimedia-IO-Funktionen soweit gekapselt, da√ü Sie sich keine Gedanken um Details machen m√ºssen.</p>
		<pre><code>
HMMIO ioHandle;
MMCKINFO ckInRIFF;
MMCKINFO fmtChunk;
MMCKINFO dataChunk;
WAVEFORMATEX format;

IoHandle = mmioOpen(‚Äútest.wav‚Äú,0,MMIO_READ);
fmtChunk.ckid = mmioFOURCC(‚Äôf‚Äô,‚Äôm‚Äô,‚Äôt‚Äô,‚Äô ‚Äô);
dataChunk.ckid = mmioFOURCC(‚ÄôD‚Äô,‚ÄôA‚Äô,‚ÄôT‚Äô,‚ÄôA‚Äô);
// In den RIFF-Chunk wechseln
mmioDescend(ioHandle, &amp;ckInRIFF, NULL, 0);
// in den Format-Chunk wechseln
mmioDescend(ioHandle, &amp;fmtChunk, &amp;ckInRIFF,
	MMIO_FINDCHUNK);
// Wave-Format lesen
mmioRead(ioHandle, &amp;format, sizeof (format));
// zur√ºck in den RIFF-Chunk
mmioAscend(ioHandle, fmtChunk, 0);

// In den Daten-Chunk wechseln
mmioDescend(ioHandle, &amp;dataChunk, &amp;ckInRIFF,
	MMIO_FINDCHUNK);
// Daten lesen
mmioRead(ioHandle, samples, dataChunk.cksize);
// und Datei wieder schlie√üen
mmioClose (ioHandle, 0);
		</code></pre>
		<p>Wenn Sie sich intensiver mit der Idee der auf Chunks basierenden Dateien auseinander&shy;setzen, werden Sie sicher viele Vorteile finden. RIFF-Dateien k√∂nnen Sie selbst&shy;verst√§ndlich nicht nur f√ºr die Windows-eigenen Datentypen benutzen. Entwerfen Sie Ihren eigenen Dateityp und schreiben Sie hinein, was immer Sie m√∂chten.</p>
	</section>

	<section>
		<h2>Klangsynthese</h2>
		<p>Jetzt, wo Sie wissen, wie Sie <i>wav</i>-Dateien abspielen, m√∂chten Sie sicherlich Ihre eigenen Soundeffekte f√ºr Ihr Spiel generieren und speichern. Falls Sie nicht mit einem Mikrofon losziehen und echte Ger√§usche aufnehmen (samplen), erzeugen Sie die Kl√§nge k√ºnstlich. Diese synthe&shy;tisierten Kl√§nge k√∂nnen das Ergebnis einer elektronischen Schaltung sein oder aber von einem PC berechnet werden. Die wichtigsten hier verwendeten Begriffe zur Klangsynthese finden Sie im Glossar auf S. 230.</p>
		<p>Wenn Sie einer etwas √§lteren Soundkarte lauschen, die noch nicht √ºber Wavetable-Kl√§nge verf√ºgt, stammen die T√∂ne wahrscheinlich von OPL2- bzw. OPL3-Chips. Diese Chips arbeiten nach der FM-Synthese und sind noch immer sehr verbreitet, etwa auf den Sound-Blaster-Karten und allen mehr oder weniger kompatiblen Konkurrenten.</p>
		<p>Die T√∂ne, die physikalisch nichts anderes sind als Schwingungen, entstehen in diesen Chips durch mehrere Schwingkreise, auch Oszillatoren genannt. Diese arbeiten entweder unabh√§ngig voneinander oder so gekoppelt, da√ü beim OPL2-Chip jeweils zwei (beim OPL3Chips sogar vier) Oszillatoren ihre aktuelle Phasenposition in Wechselwirkung beeinflussen. Eine ADSR-H√ºllkurve ‚Äì die Abk√ºrzung ADSR finden Sie im ‚ÄûGlossar zur Klangsynthese‚Äú, S. 230 ‚Äì modifiziert dabei die Ausgabe&shy;lautst√§rke der Schwingkreise (siehe Bild S. 229)</p>
		<figure class="floatright">
			<img src="assets/199905_4.png" width="302" height="114" alt="IN DIESER SCHEMATISCHEN Beispiel&shy;zeichnung verwendet jeder Operator das dar√ºber&shy;liegende Signal als Eingang.">
			<figcaption><span>IN DIESER SCHEMATISCHEN</span> Beispiel&shy;zeichnung verwendet jeder Operator das dar√ºber&shy;liegende Signal als Eingang.</figcaption>
		</figure>
		<p>Im Gegensatz zur FM-Synthese mischt die Wavetable-Synthese zuvor aufgenommene Samples von echten Instrumenten, die entweder im ROM oder RAM der Soundkarte gespeichert sind, zu einem Klang zusammen. Damit Sie auch ohne Programmier&shy;aufwand Ihre individuellen Ger√§usche zusammen&shy;stellen k√∂nnen, haben wir au√üer den Routinen zum Laden und Berechnen der Kl√§nge noch einen komfortablen Soundeditor geschrieben (siehe Bild S. 230).</p>
		<p>Ein Beispiel&shy;programm zur Berechnung der Sounds finden Sie in der Archivdatei <i>MakeSound.exe</i>, den Soundeditor in der Datei <i>FSSEditor.exe</i>.</p>
		<p>Die Klangsynthese, die dieser Editor verwendet, arbeitet mit einer ganzen Reihe von (zeitweise) abh√§ngigen Oszillatoren und Filtern. Um die Ausgabe der Oszillatoren zu beeinflussen, stehen Ihnen die Parameter aus der Tabelle ‚ÄûParameter der Oszillatoren‚Äú auf S. 233 zur Verf√ºgung.</p>
		<figure class="floatleft">
			<img src="assets/199905_3.png" width="399" height="276" alt="DIE ADSR-H√úLLKURVE bestimmt mit ihren vier Parametern die Lautst√§rke des generierten Tons.">
			<figcaption><span>DIE ADSR-H√úLLKURVE</span> bestimmt mit ihren vier Parametern die Lautst√§rke des generierten Tons.</figcaption>
		</figure>
		<p>Filtern Sie die durch die Oszillatoren erzeugte Schwingung. Dieses Verfahren verwendet einen relativ einfachen Filter&shy;algorithmus, dessen mathematische bzw. physikalische Funktionsweise uns hier nicht weiter besch√§ftigen soll. Die damit modellierten Filter besitzen zwei Parameter:<br>
		‚Ä¢ Die sogenannte Cut-off-Frequenz gibt an, welche Frequenz verst√§rkt wird. Die Verst√§rkung betrifft allerdings nicht nur genau die eingestellte Frequenz, sondern einen Frequenz&shy;bereich.<br>
		‚Ä¢ Der zweite Parameter ist die Resonanz, die gewisserma√üen die Hervorhebung des gew√§hlten Frequenz&shy;bereichs angibt. Die Werte der Resonanz bewegen sich sehr h√§ufig im Bereich zwischen 0,99 und 1,0.</p>
		<p>In unserem Soundeditor ist der linke, untere Kasten der Frequenz zugeordnet, der Kasten in der Mitte der Resonanz. Zus√§tzlich k√∂nnen Sie jeden der Operatoren, also Oszillator oder Filter, einzeln an- und ausschalten und Oszillatoren auch allein spielen lassen.</p>
		<figure class="floatright">
			<img src="assets/199905_1.png" width="640" height="500" alt="MIT UNSEREM SOUNDEDITOR mischen Sie per Mausklick tolle Effekte zusammen.">
			<figcaption><span>MIT UNSEREM SOUNDEDITOR</span> mischen Sie per Mausklick tolle Effekte zusammen.</figcaption>
		</figure>
		<p>Den Editor bedienen Sie vollst√§ndig √ºber die Maus. Die einzelnen Werte modifizieren Sie, indem Sie mit der Maus darauf klicken, den Knopf gedr√ºckt halten und die Maus nach links oder rechts bewegen. Genauso √§ndern Sie auch die Frequenz-, Amplituden- und Resonanzkurven in den K√§sten unten im Editorfenster. Sie wechseln bequem zwischen Oszillator und Filter, indem Sie einfach den entsprechenden Typ anw√§hlen. Einstellungen gehen dadurch nicht verloren. Durch einfaches Anklicken legen Sie auch eine Wellenform fest und (de-)aktivieren Operatoren.</p>
		<p>Wie bereits erw√§hnt, sind die Operatoren bedingt voneinander abh√§ngig. Ein Filter beeinflu√üt die Ausgabe aller Operatoren mit einer niedrigeren Operatornummer als die eigene, sofern sich die Zeitbereiche √ºberlappen. Ein Operator addiert seinen Ausgang einfach auf das (Zwischen-) Ergebnis aller Operatoren mit niedrigerer Nummer hinzu.</p>
		<p>Am besten sehen Sie das an einem kleinen Beispiel (siehe Bild S. 233): Oszillator 2 addiert seinen Ausgang auf Oszillator 1, er mischt ihn also hinzu. Filter 1 filtert das Ergebnis der beiden Oszillatoren. Filter 2 filtert zuerst den Ausgang von Filter 1, und nachdem dieser nicht mehr aktiv ist, direkt den Ausgang der beiden Oszillatoren. Sie lernen die genaue Funktionsweise dieser Verfahren kennen, indem Sie die beigelegten Beispiel&shy;effekte durch Herumprobieren ver√§ndern. Mit dem Soundeditor generieren Sie statt Spieleffekte auch problemlos Instrument- und Schlagzeug&shy;samples.</p>
	</section>

	<aside>
		<h2>PARAMETER DER OSZILLATOREN BEI DER KLANGSYNTHESE</h2>
		<div>
			<table>
				<thead>
					<tr><th>Parameter</th><th>Bedeutung</th><th>Bemerkung</th></tr>
				</thead>
				<tbody>
					<tr><td>Start- und Endzeit</td><td>Zeitintervall, in dem der Oszillator einen Klang erzeugt</td><td>Angabe in Millisekunden</td></tr>
					<tr><td>Start- und Endfrequenz</td><td>Frequenz, mit der der Oszillator am Beginn bzw. am Ende seiner Spielzeit schwingt</td><td>Graph im linken unteren Eck des Editorfensters zeigt Verlauf an</td></tr>
					<tr><td>Start- und Endamplitude</td><td>Anfangs- und Endlautst√§rke des Oszillators</td><td>Graph unten in der Mitte zeigt Verlauf an</td></tr>
					<tr><td>Noise Factor</td><td>Ma√ü f√ºr die zuf√§llige √Ñnderung der Oszillator&shy;phase</td><td><i>0</i> = keine Phasen√§nderung,<br><i>1</i> = maximale Phasen√§nderung (mit dieser Einstellung k√∂nnen Sie Rauschen erzeugen)</td></tr>
					<tr><td>Curve Tone</td><td>Exponentielle Umrechnung des Oszillator&shy;ausgangs</td><td>Bei einer S√§gezahn&shy;schwingung sehen Sie die Auswirkungen am besten.</td></tr>
					<tr><td>Waveform</td><td>Sinus-, S√§gezahn- oder Rechteck&shy;schwingung</td><td>Im Graphen rechts unten im Editorfenster erkennen Sie auch die Auswirkungen des Noise-Faktors.</td></tr>
				</tbody>
			</table>
		</div>
	</aside>

	<section>
		<h2>Blick hinter die Kulissen</h2>
		<p>Um aus den eingestellten Parametern ein Sample zu berechnen, gehen Sie folgenden Weg: Legen Sie f√ºr jeden Operator zus√§tzliche Variablen f√ºr die aktuelle Phasenposition und das Zwischen&shy;ergebnis der Berechnung an. Diese setzen Sie nat√ºrlich vor jeder Berechnung eines Sample-Werts auf 0.</p>
		<p>Nun behandeln Sie f√ºr jeden Sample-Wert alle Operatoren nacheinander, die zum aktuellen Zeitpunkt aktiv sind. Handelt es sich um einen Oszillator, dann berechnen Sie anhand der aktuellen Frequenz die Phasen&shy;ver√§nderung seit dem letzten Sample-Wert und die aktuelle Amplitude. Diese beiden Werte ergeben sich aus der Start- und Endfrequenz sowie der exponentiellen Funktion des Frequenz&shy;graphen.</p>
		<p>Addieren Sie das Phasendelta auf die Phasenposition, und z√§hlen Sie noch einen Zufallswert hinzu, den Sie vorher mit dem <i>Noise Factor</i> multiplizieren. Schlie√ülich bestimmen Sie aus der Phasenposition den aktuellen Wert der Schwingung und modifizieren ihn mit dem Wert von <i>Curve Tone</i>.</p>
		<p>Hier noch einmal das Prinzip des Oszillators in Pseudo&shy;quellcode:</p>
		<pre><code>
Berechne Amplitude und Frequenzdelta
Phase += Frequenzdelta + Zufallswert * Noise Factor
Ausgangswert= (Schwingfunktion(Phase) ^ Curve Tone) * Amplitude
Zwischenergebnis += Ausgangswert
		</code></pre>
		<p>Handelt es sich beim aktuellen Operator hingegen um einen Filter, so schreiben Sie diesen Wert in den Filter und lesen das Ergebnis nach dem Filtern wieder aus. Das Ergebnis erhalten Sie durch in der Filterstruktur gespeicherte Werte sowie den neu hinzu&shy;gekommenen Wert. Der Pseudocode sieht dann folgenderma√üen aus:</p>
		<pre><code>
Berechne Cutoff-Frequenz und Resonanz und setze diese Werte
Schreibe Zwischenergebnis in den Filter
Zwischenergebnis=Filterergebnis
		</code></pre>
		<p>Die genaue Implemen&shy;tierung sehen Sie in den Quelltexten ein. Aber auch ohne dieses Hintergrund&shy;wissen zur Klangsynthese k√∂nnen Sie sich nun die gew√ºnschten Kl√§nge f√ºr Ihr Spiel zurechtbasteln. In der n√§chsten Ausgabe legen Sie dann mit der Programmierung von Sprites und einem Partikel- und Effektsystem den Grundstein f√ºr Ihre Spielegrafik. Im √ºbern√§chsten und letzten Teil f√ºgen Sie daraus ein vollwertiges Arcade-Game zusammen.</p>
	</section>

	<aside>
		<h2>ENTWICKLUNGSSTUFEN DES SPIELEPROJEKTS</h2>
		<div>
			<p><b>Teil 1:</b><br>
			‚Ä¢ Entwicklung des Basissystems<br>
			‚Ä¢ DirectSound-Programmierung <br>
			‚Ä¢ Soundeffekt-Programmierung/Klangsynthese</p>
			<p><br><b>Teil 2:</b><br>
			‚Ä¢ Sprite-Programmierung<br>
			‚Ä¢ Partikel- und Effektsystem</p>
			<p><br><b>Teil 3:</b><br>
			‚Ä¢ Algorithmen zur Kollisionsabfrage<br>
			‚Ä¢ Spielelogik<br>
			‚Ä¢ Spielegrafik und Highscore-Routinen<br>
			‚Ä¢ Musik</p>
		</div>
	</aside>

	<footer>
		<p>R√ºdiger Pein / Burkhard M√ºller</p>
		<p>¬© 1999 WEKA Computerzeitschriften Verlag</p>
	</footer>
	</article>

	<nav class="pagenav">
		<a rel="prev" href="199904.html">4/1999</a>
		<a href="index.html">Inhalt</a>
		<a rel="next" href="199906.html">6/1999</a>
	</nav>
</body>
