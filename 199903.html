<!DOCTYPE html>
<html lang="de">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="style.css">
	<title>Auf direktem Wege (PC Underground, PC Magazin 3/1999)</title>
</head>
<body>
	<div class="credits">
		<h2>Dieser Artikel erschien erstmals im PC&nbsp;Magazin&nbsp;3/1999. Die Wieder&shy;ver√∂ffentlichung erfolgt mit freundlicher Genehmigung der <a rel="external nofollow noreferrer" href="https://www.weka-media-publishing.de">WEKA&nbsp;Media&nbsp;Publishing&nbsp;GmbH</a>.</h2>
	</div>

	<nav class="pagenav">
		<a rel="prev" href="199902.html">2/1999</a>
		<a href="index.html">Inhalt</a>
		<a rel="next" href="199904.html">4/1999</a>
	</nav>

	<article>
	<header>
		<h2>Demo-Programmierung unter Windows 95/NT</h2>
		<h1>Auf <span class="highlight">direktem</span> Wege</h1>
		<p class="summary">Programmieren Sie <span class="highlight">schnelle Grafik mit DirectX</span>, und nutzen Sie Ihre Demos als Bildschirmschoner.</p>
	</header>

	<section>
		<h3>Carsten Dachsbacher/Nils Pipenbrinck</h3>
		<p>Windows-Anwendungen stellen Grafiken meist √ºber das Graphics Device Interface (GDI) dar. Diese Schnittstelle enth√§lt ein sehr aufwendiges System zur Fenster&shy;verwaltung. Au√üerdem bietet sie viele Funktionen, um einfache grafische Objekte wie Linien und Rechtecke zu zeichnen.</p>
		<p>Bei der Demo-Programmierung liegt Ihr Interesse aber weniger in der Fenster&shy;verwaltung als vielmehr in maximaler Geschwindig&shy;keit.</p>
		<p>Um dem allgemeinen Wunsch nach mehr Grafik-Power gerecht zu werden, hat Microsoft mit dem Erscheinen von Windows 95 eine zweite Schnittstelle f√ºr schnellere Grafik geschaffen: Sie hei√üt DirectX und erfreut sich vor allem bei Spielen gro√üer Beliebtheit.</p>
		<p>Die Struktur von DirectX wollen wir uns genauer ansehen. Als Anwendungs&shy;beispiel schreiben Sie eine Grafik&shy;bibliothek, die einen echten Vollbildmodus unter DirectDraw ‚Äì einem Bestandteil von DirectX ‚Äì bietet. Sie verwenden dabei relativ einfache Aufrufe, die mit DirectX ab Version 3.0 zusammen&shy;arbeiten (neuere Versionen sind abw√§rts&shy;kompatibel).</p>
	</section>

	<aside>
		<h2>QUELLTEXTE</h2>
		<div>Die Quelltexte zu diesem Artikel finden Sie in der Datei  <a href="199903.zip">üíæ 199903.zip</a>.</div>
	</aside>

	<section>
		<h2>Das Besondere an DirectX</h2>
		<p>Mit DirectX begann Microsoft, ein neues Modell f√ºr Programmier&shy;schnittstellen zu verwenden. Es ist das Component Object Model (COM). Die alte, auf Funktionen basierende Schnittstelle sollte durch eine objekt&shy;orientierte ersetzt werden. Dabei traten zwei technische Probleme auf: Zum einen booten nicht alle Windows-Programmier&shy;sprachen objekt&shy;orientierte Funktionen, zum anderen lassen sich mit DLL-Bibliotheken keine Objekte exportieren.</p>
		<p>F√ºr den C++-Programmierer sieht der DirectX-Quelltext objekt&shy;orientiert aus. In Wirklichkeit t√§uschen Makros nur die Objekt&shy;orientierung vor. Bereiten Sie sich daher auf au√üer&shy;gew√∂hnliche Fehler&shy;meldungen Ihres C-Compilers vor, denn dieser sieht den Code anders, als Sie ihn eingeben.</p>
		<p>DirectX ist die der Hardware am n√§chsten stehende Schnittstelle, die die Windows-API zu bieten hat. Daher ist sie besonders fehleranf√§llig. Sie sollten stets den R√ºckgabewert von DirectX-Funktionen √ºberpr√ºfen: Wenn Sie einen Fehler ignorieren, kann nicht nur Ihr Programm, sondern das gesamte Windows-System abst√ºrzen.</p>
		<p>Im Gegensatz zu gew√∂hnlichen C++Objekten gibt es bei DirectX keine Konstruktoren und Destruktoren. F√ºr jedes Objekt existiert statt dessen eine Initialisierungs-Funktion. Zus√§tzlich besitzt jedes DirectX-Objekt eine Release-Funktion als Ersatz f√ºr einen Objekt&shy;destruktor. Diese Funktionen m√ºssen Sie selbst aufrufen.</p>
		<figure class="floatright">
			<img src="assets/199903_2.png" width="256" height="256" alt="UNSER BILDSCHIRMSCHONER greift f√ºr den Tunnel-Effekt auf diese externe Bitmap-Datei zu.">
			<figcaption><span>UNSER BILDSCHIRM&shy;SCHONER</span> greift f√ºr den Tunnel-Effekt auf diese externe Bitmap-Datei zu.</figcaption>
		</figure>
		<p>Von Version zu Version hat Microsoft einige √Ñnderungen und Verbesserungen an den DirectX-Objekten vorgenommen. Um zu alten Programmen und verschiedenen installierten Versionen von DirectX kompatibel zu bleiben, gibt es einen interessanten Versions-Mechanismus: Wenn Sie von DirectX ein Objekt anfordern, bekommen Sie zun√§chst ein Objekt der Version 1.0, das Sie nach einer neueren Version von DirectX fragen k√∂nnen.</p>
		<p>Eine zentrale Rolle spielen die sogenannten GUIDs (Globally Unique Identifiers). Das sind eindeutige Zahlencodes, die Windows jedem Objekt zuordnet. So kann Windows die Objekte voneinander unterscheiden. Wenn Sie ein DirectDraw-Objekt der Version 3.0 w√ºnschen, sollten Sie die entsprechende GUID f√ºr dieses Objekt kennen.</p>
		<p>Laut Microsoft soll der zugrunde&shy;liegende Algorithmus erst um das Jahr 3400 herum bereits verwendete Identifikations&shy;nummern doppelt vergeben. Diese Weit&shy;sichtigkeit erspart der Computerwelt ein √§hnliches Chaos wie beim Jahr-2000-Problem.</p>
	</section>

	<section>
		<h2>DirectDraw und dessen Objekte</h2>
		<p>In den abgedruckten Listingzeilen haben wir der √úbersicht&shy;lichkeit zuliebe auf die Fehler&shy;behandlung verzichtet. Dieser Code soll Ihnen das Prinzip und die Schnittstelle nahebringen; guten Programmier&shy;stil bietet dagegen der Code der neuen Demobibliothek auf der Heft-CD.</p>
		<p>Den Zugriff auf eine Grafikkarte liefert Ihnen das Objekt <i>IDirectDraw</i>:</p>
		<pre><code>
IDirectDraw* dd = NULL;
GUID* ddGUID = NULL;
DirectDrawCreate(ddGUID, &amp;dd, NULL);
		</code></pre>
		<p>Dieser Code erzeugt ein <i>IDirectDraw</i>-Objekt und speichert den Pointer darauf in <i>dd.ddGUID</i> dient dazu, mehrere im System installierte Grafikkarten zu unterscheiden. Falls Sie ‚Äì wie hier im Beispiel ‚Äì <i>ddGUID</i> auf 0 setzen, kommt die Standard-Grafikkarte zum Einsatz.</p>
		<p>Im n√§chsten Schritt teilen Sie Windows mit, da√ü Ihr Programm von nun an der alleinige Besitzer der Grafikkarte sein soll. Dies erreichen Sie mit</p>
		<pre><code>
dd->SetCooperativeLevel(ParentWindow,
	DDSCL_EXCLUSIVE |
	DDSCL_FULLSCREEN |
	DDSCL_ALLOWREBOOT);
		</code></pre>
		<figure class="floatright">
			<img src="assets/199903_3.png" width="410" height="460" alt="DEN AKTIVEN BILDSCHIRMSCHONER legen Sie in der Systemsteuerung im Men√ºpunkt Anzeige fest.">
			<figcaption><span>DEN AKTIVEN BILDSCHIRM&shy;SCHONER</span> legen Sie in der System&shy;steuerung im Men√ºpunkt Anzeige fest.</figcaption>
		</figure>
		<p>Das erste Argument, das Sie √ºbergeben, ist der Handle eines Fensters. Wie Sie die Fensterklasse definiert haben, ist egal ‚Äì sie mu√ü allerdings vom aktuell laufenden Programm erzeugt worden sein. Die drei durch ein logisches Oder verkn√ºpften Flags im zweiten Parameter geben Ihnen vollen Zugriff auf die Grafik-Hardware.</p>
		<p>Ist obiger Befehl ausgef√ºhrt, wirkt sich jeder Absturz fatal auf Windows aus. Sollte Ihr Programm abst√ºrzen, k√∂nnen Sie den Fehlerdialog weder sehen noch bedienen, sondern m√ºssen den Rechner neu starten. Jetzt brauchen Sie eine neuere Version des DirectDraw-Objekts:</p>
		<pre><code>
IDirectDraw2* dd2 = NULL;
dd->QueryInterface(
	IID_IDirectDraw2,
	(void **) &amp;dd2);
		</code></pre>
		<p><i>IDD_IDirectDraw2</i> ist die GUID der zweiten Version von DirectDraw. Die Variable <i>dd2</i> ist nach Aufruf dieser Funktion ein Objekt vom Typ <i>DirectDraw2</i>. Damit k√∂nnen Sie den Videomodus wechseln:</p>
		<pre><code>
dd2->SetDisplayMode(320, 240, 16, 0, 0);
	</code></pre>
		<p>Die ersten drei Parameter stehen f√ºr die Breite, H√∂he und Farbtiefe des Videomodus. Mit dem vierten Parameter √§ndern Sie die Bildwieder&shy;holfrequenz. Eine 0 setzt die Wiederhol&shy;frequenz auf Standardwerte. Das letzte Argument hat noch keine Bedeutung und ist f√ºr sp√§tere Erweiterungen von DirectX gedacht.</p>
		<p>Die erste H√ºrde ist genommen: Sie haben einen Videomodus Ihrer Wahl und sind im Exclusive-Modus von DirectDraw. Aber wie schreiben Sie jetzt Daten in den Grafikspeicher? Daf√ºr brauchen Sie weitere Objekte.</p>
	</section>

	<aside>
		<h2>DEMOS ALS BILDSCHIRM&shy;SCHONER</h2>
		<div>
			<p>Sie m√∂chten Ihrem Windows-System eine pers√∂nliche Note geben? Dann verwenden Sie Ihre bisher geschriebenen Demos als Bildschirm&shy;schoner.</p>
			<p>Ein Windows-Bildschirm&shy;schoner mit der Dateiendung .scr ist vom Aufbau her identisch mit einer exe-Datei. Wie sich das jeweilige Programm verh√§lt, entscheidet sich beim Aufruf:<br>
			‚Ä¢ Mit dem Kommandozeilen&shy;parameter /c starten Sie einen Konfigurations&shy;dialog,<br>
			‚Ä¢ mit /s einen Schoner.<br>
			‚Ä¢ Ein Aufruf ohne Parameter ‚Äì etwa wenn Sie selbst eine scr-Datei ausf√ºhren ‚Äì wird wie ein Start mit dem Argument /s behandelt.</p>
			<p>Um die Programmierung eigener Bildschirm&shy;schoner zu erleichtern, stellt Microsoft √ºber die Win32-API die Bibliothek scrnsave.lib bereit, die alle Windows-spezifischen Aufgaben erledigt. Sie legt automatisch ein Vollbild&shy;fenster an, deaktiviert den Mauszeiger und setzt die registrierte Fensterklasse auf <i>WS_EX_TOPMOST</i>, damit sich das Fenster immer im Vordergrund befindet. So k√∂nnen Sie sich ganz auf die Gestaltung der Dialoge und des Bildschirm&shy;schoners konzentrieren.</p>
			<p>Ebenfalls in dieser Bibliothek befinden sich die Funktion WinMain und der Message-Handler. Letzterer steuert alle f√ºr Bildschirm&shy;schoner typischen Verhaltens&shy;weisen: So wird der Bildschirm&shy;schoner beim Bewegen der Maus oder durch einen Tastendruck beendet.</p>
			<p>In unserer neuen Grafik&shy;bibliothek demosys.cpp w√§hlen Sie mit <span class="code">#define SCREENSAVER</span> die Kompilierung zum Bildschirm&shy;schoner.</p>
			<p>In diesem Fall werden die von <i>scrnsave.lib</i> geforderten Schnittstellen-Prozeduren definiert und die Header-Datei <i>scrnsave.h</i> eingebunden. Die Prozedur <span class="code">LONG WINAPI ScreenSaverProc(...)</span> enth√§lt Ihren Message-Handler f√ºr den Bildschirm&shy;schoner. Alle Nachrichten, die Sie nicht bearbeiten wollen, √ºbergeben Sie an den von <i>scrnsave.lib</i> bereit&shy;gestellten Message-Handler <i>DefScreenSaverProc(...)</i>. Nach dem Empfang der Nachricht <i>WM_CREATE</i> initialisieren Sie ‚Äì wie bisher in WinMain(...) ‚Äì die Demobibliothek und starten den Thread des Demos.
			Erhalten Sie die Nachricht <i>WM_DESTROY</i>, rufen Sie zum Beenden die <i>demoquit()</i>-Funktion der Demo auf.</p>
			<p>An der Demo selbst √§ndert sich nichts. Damit k√∂nnen Sie alle bisher in PC Underground entwickelten Programme ohne √Ñnderungen als Bildschirm&shy;schoner verwenden.</p>
			<p>Bei der Prozedur <i>ScreenSaverConfigureDialog(...)</i> handelt es sich auch um einen Message-Handler, der einen Konfigurations&shy;dialog bereitstellen soll. Sie k√∂nnen einen solchen Dialog mit einem Ressourcen-Editor erzeugen und an dieser Stelle in das Demosystem einbauen. Die Konfigurations&shy;daten sollten Sie in der Registry sichern. W√ºnschen Sie keinen Konfigurations&shy;dialog, verwenden Sie einfach folgenden minimalen Dialog, der nicht einmal ein Fenster √∂ffnet:</p>
			<pre><code>
BOOL WINAPI
	ScreenSaverConfigureDialog(
		HWND hdlg,UINT message,
		WPARAM wparam,LPARAM lparam)
{
	switch (message)
	{
		case WM_INITDIALOG:
			return TRUE;
		case WM_COMMAND:
			switch (LOWORD(wparam))
			{
				case IDOK:
				case IDCANCEL:
					EndDialog(hdlg,TRUE);
					return TRUE;
			}
	}
	return FALSE;
}

BOOL WINAPI
	RegisterDialogClasses(
	HANDLE hinst)
{
	return TRUE;
}
			</code></pre>
			<p>Ein Bildschirm&shy;schoner unter Windows enth√§lt normalerweise alle Daten (Bitmaps, Wave-Dateien oder Videosequenzen) als Ressourcen; das hei√üt, sie sind in der exe- bzw. scr-Datei enthalten. Unser Programm&shy;beispiel PC Underground Screen Saver.scr, das Sie in das Windows- oder das System32-Verzeichnis kopieren, verlangt die Bitmap-Grafik tunnel2.bmp im Haupt&shy;verzeichnis Ihrer Festplatte C:.</p>
			<p>Ihren Bildschirm&shy;schoner sollten Sie im DirectX-Vollbildmodus laufen lassen, weil die GDI-Funktion <i>StretchDIBits(...)</i> zum Skalieren eines Bildes auf Bildschirm&shy;gr√∂√üe sehr langsam ist.</p>
		</div>
	</aside>

	<section>
		<h2>DirectDraw-Surfaces</h2>
		<p>Mit den sogenannten Surfaces (Oberfl√§chen) verwalten Sie den Videospeicher. DirectDraw bietet viele verschiedene Arten von Surfaces. Solange Sie nur an einem einfachen Zugriff auf den Videospeicher interessiert sind, bleibt alles relativ einfach:</p>
		<pre><code>
DDSURFACEDESC SurfaceDesc;
memset(&amp;SurfaceDesc, 0, sizeof(SurfaceDesc));
SurfaceDesc.dwSize = sizeof(SurfaceDesc);
		</code></pre>
		<p>Um die gew√ºnschten Eigenschaften festzulegen, f√ºllen Sie eine Struktur vom Typ <i>DDSURFACEDESC</i> aus. Machen Sie das sorgf√§ltig, denn (wie bereits erw√§hnt) ist DirectDraw nicht gerade fehlertolerant.</p>
		<p>Die Struktur <i>SurfaceDesc</i> f√ºllen Sie zuerst mit Null-Bytes und initialisieren das Feld <i>dwSize</i> mit der Gr√∂√üe der Struktur. DirectDraw stellt damit fest, mit welcher Version von DirectX Sie Ihr Programm √ºbersetzt haben.</p>
		<pre><code>
SurfaceDesc.ddsCaps.dwCaps =
	DDSCAPS_PRIMARYSURFACE |
	DDSCAPS_FLIP |
	DDSCAPS_COMPLEX;
SurfaceDesc.dwBackBufferCount=1;
		</code></pre>
		<p>Die Daten im Feld <i>ddsCaps.dwCaps</i> beschreiben die Art der Oberfl√§che, die Sie anfordern: hier darstellbaren Videospeicher (<i>DDSCAPS_PRIMARYSURFACE</i>), der Page-Flipping (<i>DDSCAPS_FLIP</i> und <i>DDSCAPS_COMPLEX</i>) beherrscht. Das hei√üt: Sie k√∂nnen zwischen mehreren virtuellen Bildschirmen hin- und herschalten. F√ºr das Page-Flipping ben√∂tigen Sie mindestens noch eine zweite Bildschirm&shy;seite. In <i>dwBackBufferCount</i> geben Sie die Anzahl der zus√§tzlichen Bildschirm&shy;seiten an und legen in <i>dwFlags</i> fest, da√ü Sie folgenden Wert setzen wollen:</p>
		<pre><code>
SurfaceDesc.dwFlags =
	DDSD_CAPS |
	DDSD_BACKBUFFERCOUNT;
		</code></pre>
		<p>Teilen Sie DirectDraw mit, welche Informationen Sie in der Struktur gesetzt haben. Da viele verschiedene Arten von Surfaces existieren, mu√ü DirectDraw genau wissen, welche Art von Surface Sie haben m√∂chten.</p>
		<p>Dieser Code legt die Oberfl√§che nach Ihren W√ºnschen an:</p>
		<pre><code>
IDirectDrawSurface ddSurface = 0;
dd2->CreateSurface(&amp;SurfaceDesc, &amp;ddSurface, 0);
		</code></pre>
		<p>Dabei wird <i>ddSurface</i> ‚Äì falls Sie keinen Fehler gemacht haben ‚Äì mit einem <i>IDirectDrawSurface</i> -Objekt initialisiert.</p>
	</section>

	<section>
		<h2>Page-Flipping unter DirectDraw</h2>
		<figure class="floatright">
			<img src="assets/199903_1.png" width="635" height="599" alt="BEIM PAGE-FLIPPING vertauscht DirectDraw einfach die sichtbare mit der unsichtbaren Oberfl√§che.">
			<figcaption><span>BEIM PAGE-FLIPPING</span> vertauscht DirectDraw einfach die sichtbare mit der unsichtbaren Oberfl√§che.</figcaption>
		</figure>
		<p>Mit dem in DirectDraw eingebauten Page-Flipping wechseln Sie schnell zwischen mehreren Bildschirm&shy;seiten. Das Prinzip ist sehr einfach: Die Oberfl√§che, die Sie eben angelegt haben, besteht aus zwei Bildschirm&shy;seiten. Eine davon ist sichtbar, w√§hrend Sie den Inhalt der anderen Seite √§ndern k√∂nnen, ohne Darstellungs&shy;fehler zu erhalten. Sie brauchen sich nicht einmal darum zu k√ºmmern, welche der Seiten gerade sichtbar ist. DirectDraw √ºbernimmt diese Verwaltungs&shy;aufgabe f√ºr Sie.</p>
		<p>Wenn Sie herausfinden wollen, welche Oberfl√§che Sie gerade √§ndern d√ºrfen, fragen Sie Ihre sichtbare Surface einfach nach dem Back-Buffer, also der zweiten Bildschirm&shy;seite. F√ºllen Sie eine <i>DDSCAPS</i>-Struktur, und teilen Sie DirectDraw mit, da√ü Sie am BackBuffer interessiert sind:</p>
		<pre><code>
DDSCAPS caps;
caps.dwCaps = DDSCAPS_BACKBUFFER;
		</code></pre>
		<p>Nun fordern Sie von der aktiven Surface die n√§chste zum Zeichnen verf√ºgbare Seite an:</p>
		<pre><code>
IDirectDrawSurface* dds;
ddSurface->GetAttachedSurface(&amp;caps, &amp;dds);
		</code></pre>
		<p>Die Variable <i>dds</i> wird dabei mit der Hintergrund-Surface initialisiert, und Sie d√ºrfen mit dem Zeichnen anfangen.</p>
		<p>Wenn Sie auf eine Surface zugreifen, √§ndern Sie immer automatisch die nicht sichtbare Bildschirm&shy;seite. Sobald Sie DirectDraw mitteilen, da√ü Sie fertig sind und umschalten m√∂chten, werden die beiden Seiten ausgetauscht.</p>
		<p>Das kostet kaum Rechenzeit, da der Wechsel der Bildschirm&shy;seiten in der Grafik-Hardware vonstatten geht. Die Surfaces befinden sich ‚Äì sofern genug Grafikkarten&shy;speicher vorhanden ist ‚Äì im Speicher der Karte und nicht im Hauptspeicher des Computers. Zudem wartet DirectDraw vor dem Umschalten darauf, da√ü der Monitor das Bild komplett aufgebaut hat. Diese Vorgehensweise verhindert Darstellungs&shy;fehler, die zum Beispiel entstehen, wenn Sie w√§hrend des Bildaufbaus auf das n√§chste Bild umschalten.</p>
		<p>Page-Flipping mit einem Bild im Hintergrund hei√üt Double-Buffering. Es funktioniert aber auch mit zwei (Triple-Buffering) oder mehr inaktiven Bildschirm&shy;seiten. Verwenden Sie etwa eine Zeichenroutine, die ein Bild schneller aufbaut als der Monitor, k√∂nnen Sie einige Bilder schon im voraus berechnen. Diese werden dann automatisch der Reihe nach abgespielt.</p>
		<p>So starten Sie das Page-Flipping bei DirectDraw: Nachdem Sie ein Bild vollst√§ndig gezeichnet haben, rufen Sie die <i>Flip</i>-Funktion des <i>IDirectDrawSurface</i>-Objekts auf:</p>
		<pre><code>
ddSurface->Flip(0, DDFLIP_WAIT)
		</code></pre>
		<p>√úbergeben Sie der Funktion zwei Parameter. Mit dem ersten √§ndern Sie die automatische Reihenfolge des Page-Flipping. F√ºr unsere Zwecke ist das uninteressant. Der zweite Parameter <i>DDFLIP_WAIT</i> signalisiert, da√ü Sie mit dem Umschalten warten m√∂chten, bis der Monitor das Bild komplett aufgebaut hat. Der Wechsel zwischen den Bildschirm&shy;seiten geschieht also genau dann, wenn der Rasterstrahl das untere Ende des Monitors erreicht hat und wieder nach oben an den Anfang l√§uft.</p>
	</section>

	<aside>
		<h2>DIE KOMPONENTEN DES DIRECTX-SDK</h2>
		<div>
			<table>
				<thead>
					<tr><th>Komponente</th><th>Funktion</th></tr>
				</thead>
				<tbody>
					<tr><td>DirectDraw</td><td>Direktzugriff auf Bitmaps im Grafikspeicher, schnelles Hardware-Flipping</td></tr>
					<tr><td>DirectSound</td><td>Mischen und Wiedergabe von Sounds</td></tr>
					<tr><td>DirectPlay</td><td>Verbindung f√ºr Modem- und Netzwerkspiele</td></tr>
					<tr><td>Direct3D</td><td>Komplettes 3D-Grafiksystem mit direkter Kontrolle der Rendering-Pipeline</td></tr>
					<tr><td>DirectInput</td><td>Eingabe&shy;routinen f√ºr Joystick, Maus und Tastatur</td></tr>
					<tr><td>DirectSetup</td><td>Installations&shy;prozedur f√ºr DirectX</td></tr>
					<tr><td>AutoPlay</td><td>Automatischer Programmstart</td></tr>
				</tbody>
			</table>
		</div>
	</aside>

	<section>
		<h2>Zugriff auf das Surface-RAM-Flipping</h2>
		<p>Eine wichtige Frage ist noch unbeantwortet: Wie greifen Sie auf den Speicher des verdeckten Bildes zu, um dessen Inhalt zu √§ndern? Das Objekt <i>IDirectDrawSurface</i> stellt hierf√ºr zwei Funktionen zur Verf√ºgung: <i>Lock</i> und <i>Unlock</i>.</p>
		<p>Erneut kommen Sie nicht daran vorbei, eine DirectDraw-Struktur vom Typ <i>DDSURFACEDESC</i> auszuf√ºllen:</p>
		<pre><code>
DDSURFACEDESC
	SurfaceDescription;
memset(&amp;SurfaceDescription, 0, sizeof(DDSURFACEDESC));
SurfaceDescription.dwSize = sizeof(SurfaceDescription);
		</code></pre>
		<p>Dann rufen Sie die Funktion <i>Lock</i> auf, die Ihnen die Speicher&shy;adresse der Grafikdaten verr√§t:</p>
		<pre><code>
ddSurface->Lock(0,
	&amp;SurfaceDescription,
	DDLOCK_SURFACEMEMORYPTR |
	DDLOCK_WAIT, 0)
		</code></pre>
		<p>Der Pointer <i>SurfaceDescription.lpSurface</i> zeigt nun auf das Video-RAM. Auch einige andere Felder der Struktur enthalten wichtige Informationen. So gibt das Feld <i>SurfaceDescription.lPitch</i> an, wie viele Bytes Speicher DirectDraw f√ºr eine Bildschirm&shy;zeile verwendet. Das mutet im ersten Moment etwas ungew√∂hnlich an, ist aber f√ºr viele Grafikkarten erforderlich.</p>
		<p>Wenn Sie zum Beispiel einen 320 x 240 Pixel gro√üen Videomodus in Highcolor setzen, belegt eine Grafikzeile genau 640 Byte. Viele Grafikkarten arbeiten jedoch schneller, wenn dieser Wert zwar etwas gr√∂√üer, aber rechnerisch einfacher zu handhaben ist als die mindestens ben√∂tigten Bytes pro Zeile. Sie sollten dies beim Schreiben in den Videospeicher unbedingt beachten.</p>
		<p>Nach dem Zeichnen rufen Sie die <i>Unlock</i>-Funktion auf:</p>
		<pre><code>
ddSurface->Unlock(SurfaceDescription.lpSurface);
		</code></pre>
		<p>Halten Sie die Zeit zwischen <i>Lock</i> und <i>Unlock</i> immer so kurz wie m√∂glich. W√§hrend Sie auf den Videospeicher zugreifen, bleibt fast das gesamte Betriebssystem stehen. Nur noch Sie bzw. Ihr Programm bekommt Prozessorzeit. Bedenken Sie: Wenn Sie viel Rechenzeit beanspruchen, werden eventuell wichtige Systemprozesse behindert.</p>
	</section>

	<section>
		<h2>Gr√ºn bevorzugt</h2>
		<p>Jetzt sehen wir uns das 16-Bit-Farbmodell genauer an. Ein 16 Bit breites Highcolor-Pixel ist aus drei Feldern aufgebaut: Sie entsprechen den drei Farb&shy;komponenten Rot, Gr√ºn und Blau (RGB). In der Regel werden die 16 Bits so aufgeteilt, da√ü Rot und Blau je 5 Bit bekommen, w√§hrend Gr√ºn mit 6 Bit bevorzugt behandelt wird. Der Grund: Gr√ºn ist die Prim√§rfarbe mit der gr√∂√üten Helligkeit, das Auge kann sie am besten wahrnehmen. Im Schema sieht das so aus:
		<span class="code">RRRRR GGGGGG BBBBB</span>
		Einige Grafikkarten verwalten die Bits jedoch auf andere Weise. Sie verwenden einheitlich f√ºr jede Prim√§rfarbe 5 Bit und lassen daf√ºr das oberste Bit ungenutzt:<br>
		<span class="code">0 RRRRR GGGGG BBBBB</span>
		DirectDraw gibt Ihnen auf einigen Grafikkarten diesen 15-Bit-Farbmodus, obwohl Sie einen 16-Bit-Modus setzen wollten. In diesem Fall wandeln Sie die Pixel w√§hrend des Kopierens in das andere Farbformat um, um zur bisher in PC Undergound verwendeten Grafik&shy;bibliothek kompatibel zu bleiben.</p>
		<p>Damit Sie sich k√ºnftig nicht mehr darum zu k√ºmmern brauchen, enth√§lt der Code der neuen DirectX-Bibliothek bereits eine effiziente Umwandlungs&shy;routine. Dieser zus√§tzliche Verwaltungs&shy;aufwand ist der Preis f√ºr die schnelle Grafik. Das Windows-GDI-Interface w√ºrde Ihnen auch diese Arbeit abnehmen.</p>
		<p>Die Umwandlung von 16 nach 15 Bit nehmen Sie mit einigen einfachen Operationen parallel f√ºr jeweils zwei Pixel vor:</p>
		<pre><code>
unsigned long blau = pixel &amp; 0x001f001f;
unsigned long rotgr√ºn = (pixel > 1) &amp; 0xffe0ffe0;
pixel = blau | rotgr√ºn;
		</code></pre>
		<p>Zuerst maskieren Sie den Blau-Anteil aus, da er sich w√§hrend der Umwandlung nicht √§ndert. Die beiden Farb&shy;komponenten Rot und Gr√ºn schieben Sie zun√§chst bin√§r nach rechts und maskieren die gew√ºnschten Bits. Wenn Sie beide Farbanteile mit einer Oder-Verkn√ºpfung wieder zusammenf√ºgen, haben Sie das unterste Gr√ºn-Bit weggeworfen und alle √ºbrigen Farbanteile auf die richtige Position geschoben.</p>
		<p>Wir haben diese Bibliotheks&shy;routine auch in Assembler programmiert. Sie ist damit nur minimal langsamer als das direkte Kopieren des Speichers.</p>
		<p>Wenn Sie bereits mit der bisher in PC Underground verwendeten Grafik&shy;bibliothek experimentiert haben, wird Ihnen der Einsatz der neuen DirectX-Erweiterung leichtfallen.</p>
		<p>Die einzige auffallende √Ñnderung ist ein neuer Fenstermodus. Neben den vordefinierten Konstanten <i>FENSTER</i>, <i>SKALIERBAR</i> und <i>VOLLBILD</i> f√ºr die GDI-Routinen gibt es zus√§tzlich <i>DDVOLLBILD</i> f√ºr Vollbilddemos, die die Geschwindig&shy;keit von DirectDraw ausnutzen.</p>
	</section>

	<section>
		<h2>Kompilation ohne Komplikation</h2>
		<p>Um DirectX-Programme zu kompilieren, ben√∂tigen Sie das DirectX-SDK (Software Development Kit) von Microsoft. Sie beziehen es √ºber die Internet-Seite von Microsoft unter <a href="https://msdn.microsoft.com/developer/sdk/directx.htm" rel="external nofollow noreferrer">msdn.microsoft.com/developer/sdk/directx.htm</a>. Die Aufgaben seiner Komponenten entnehmen Sie der Tabelle (vorige Seite unten). Aber Achtung: Nicht jede Version von DirectX funktioniert mit jedem Compiler. Benutzer von Microsoft Visual C++ sind hier im Vorteil: Sie brauchen nichts zu tun.</p>
		<p>Bei Watcom C++ sieht das etwas anders aus. Mit Version 11 des Compilers erhalten Sie das DirectX SDK 3.0. Damit k√∂nnen Sie die hier entwickelten Programme problemlos kompilieren. Wenn Sie eine neuere Version des SDK installieren, werden Sie einiges an Handarbeit leisten m√ºssen, um alles zum Laufen zu bringen.</p>
		<p>Die DirectX-Bibliothek wird nicht ‚Äì wie die Standard&shy;bibliotheken ‚Äì automatisch zum Programm gelinkt. Darum m√ºssen Sie sich selbst k√ºmmern. F√ºr die Arbeit mit DirectDraw binden Sie die beiden Libraries <i>ddraw.lib</i> und <i>guids.lib</i> (bzw. <i>dxguids.lib</i> bei Visual C) ein.</p>
	</section>

	<footer>
		<p>R√ºdiger Pein / Burkhard M√ºller</p>
		<p>¬© 1999 WEKA Computerzeitschriften Verlag</p>
	</footer>
	</article>

	<nav class="pagenav">
		<a rel="prev" href="199902.html">2/1999</a>
		<a href="index.html">Inhalt</a>
		<a rel="next" href="199904.html">4/1999</a>
	</nav>
</body>