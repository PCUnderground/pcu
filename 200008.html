<!DOCTYPE html>
<html lang="de">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="style.css">
	<title>Auf Knopfdruck (PC Underground, PC Magazin 8/2000)</title>
</head>
<body>
	<div class="credits">
		<h2>Dieser Artikel erschien erstmals im PC&nbsp;Magazin&nbsp;8/2000. Die Wieder&shy;ver√∂ffentlichung erfolgt mit freundlicher Genehmigung der <a rel="external nofollow noreferrer" href="https://wekanet.de">WEKA&nbsp;Media&nbsp;Publishing&nbsp;GmbH</a>.</h2>
	</div>

	<nav class="pagenav">
		<a rel="prev" href="200007.html">7/2000</a>
		<a href="index.html">Inhalt</a>
		<a rel="next" href="200009.html">9/2000</a>
	</nav>

	<article>
	<header>
		<h2>DirectX 7 ‚Äì Eingabeger√§te ansteuern</h2>
		<h1>Auf <span class="highlight">Knopfdruck</span></h1>
		<p class="summary">Mit DirectInput sind Sie Herr der Eingabesysteme. Gleichg√ºltig, ob Sie Maus, Tastatur, Joystick, Game Controller oder Force-Feedback-Ger√§te ansteuern. Lesen Sie, wie Sie <span class="highlight">Ein- und Ausgabedaten verarbeiten</span>.</p>
	</header>

	<section>
		<h3>C. Dachsbacher/O. K√§ferstein</h3>
		<p>Wenn Sie ein Programm entwickeln, das mit Maus und Tastatur auskommt, k√∂nnen Sie auf DirectInput (Application Programming Interface f√ºr komplexe Ein/Ausgabeger√§te) verzichten. Dann k√∂nnen Sie alle Eingaben des Benutzers in der Windows-Message-Schleife √ºber Schl√ºssel&shy;w√∂rter wie <i>WM_CHAR, WM_MOUSEMOVE</i> abfragen und behandeln. DirectInput verwenden Sie, wenn Sie in extrem kurzen Zeitinter&shy;vallen Daten des Eingabeger√§ts ben√∂tigen oder spezielle Eingabeger√§te wie Force-Feedback-Joysticks, Lenkr√§der oder √Ñhnliches einsetzen wollen.</p>
		<p>Erst wenn Sie DirectInput initialisiert haben, k√∂nnen Sie die Eingabeger√§te ansprechen. Mit dieser Voraussetzung programmieren Sie so, dass Sie die Handlungen Ihrer Programmnutzer verarbeiten. Force-Feedback-Ger√§te (Eingabeger√§te mit Datenstr√∂men vom und zum PC) erhalten via DirectInput ihre Wirksamkeit.</p>
	</section>

	<aside>
		<h2>QUELLTEXTE</h2>
		<div>Die Quelltexte zu diesem Artikel finden Sie in der Datei  <a href="200008.zip">üíæ 200008.zip</a>.</div>
	</aside>

	<section>
		<p>DirectInput arbeitet direkt mit den Ger√§tetreibern zusammen, Maus- und Tastatur-Nachrichten (elektronische Schaltimpulse) werden unterdr√ºckt oder ignoriert. Ignoriert bedeutet, sie sind f√ºr das Input-System uninteressant und werden weitergeleitet. Unterdr√ºckt bedeutet, dass DirectInput die Daten von den Eingabeger√§ten verwendet. Dabei werden die Nachrichten, die normalerweise an Windows oder Fenster auf dem Bildschirm ausgegeben w√ºrden, nicht weitergeleitet. Wenn Sie also die Maus mit DirectInput im <i>Exclusive Mode</i> verwenden, kann Windows nicht einmal den Standard-Mauscursor darstellen, da es keine Nachrichten √ºber den Zustand der Mauskn√∂pfe oder Bewegungen bekommt.</p>
		<figure class="floatright">
			<img src="assets/200008_1.jpg" width="626" height="333" alt="HIER SEHEN SIE DIE Informationen von DirectX √ºber einen Force-Feedback-Joystick.">
			<figcaption><span>HIER SEHEN SIE DIE</span> Informationen von DirectX √ºber einen Force-Feedback-Joystick.</figcaption>
		</figure>
		<p>Wegen des engen Zusammenspiels mit den Ger√§tetreibern ignoriert Direct-Input Einstellungen, die Sie in der System&shy;steuerung f√ºr Maus oder Tastatur vornehmen. Bei der Tastatur kennt DirectInput auch keine Tasten&shy;wiederholung. Es wird nur f√ºr jede Taste unterschieden, ob sie gerade gedr√ºckt oder losgelassen ist.</p>
		<p>Auch bei der Maus kennt DirectInput keine Einstellungen der System&shy;steuerung wie Beschleunigung des Cursors oder vertauschte Kn√∂pfe. Daher gehen alle Daten am Kontrollsystem von Windows (dem Subsystem) vorbei, das sonst f√ºr die Interpretation der Mausdaten zust√§ndig w√§re.</p>
		<p>Einstellungen, die Sie direkt in den Treibern f√ºr die Eingabeger√§te vornehmen, werden ber√ºcksichtigt. Wenn Sie eine Drei-Tasten-Maus besitzen und den Treiber anweisen, einen Klick mit der mittleren Maustaste als Doppelklick zu verwenden, meldet DirectInput einen Klick mit dieser Taste als zwei Klicks mit der ersten Maustaste.</p>
		<p class="tip">Keine Regel ohne Ausnahme: Bei Joysticks verwendet DirectInput die Kalibrierungs&shy;informationen, die der Benutzer in der System&shy;steuerung eingestellt hat.</p>
		<p>Bei den Schnittstellen verschiedener Ger√§teeingaben darf das Human Interface Device (HID) nicht fehlen. Dabei handelt es sich um eine Klasse innerhalb der Universal-Serial-Bus-Standards (USB), welche USB-Eingabeger√§te ansteuert und auswertet. DirectInput unterst√ºtzt alle Ger√§te, die nach dem HID-Standard funktionieren. Im Gegensatz zu traditionellen Eingabeger√§ten k√∂nnen HID-Ger√§te zus√§tzlich Daten ausgeben. So k√∂nnen Sie zum Beispiel (wie bei Assembler-Programmen unter MS-DOS) Keyboard-LEDs an- oder ausschalten.</p>
		<p>Wenn Sie mit DirectInput ein HID-Ger√§t ausw√§hlen, k√∂nnen Sie dessen Art und F√§higkeiten auslesen, weil vordefinierte Codes Sie dar√ºber informieren. √úber den HID-Standard finden Sie weitere Informationen unter der Adresse <a href="https://www.usb.org" rel="external nofollow noreferrer">www.usb.org</a>.</p>
	</section>

	<section>
		<h2>Programm mit DirectInput</h2>
		<p>Wie bei anderen Komponenten des DirectX-Systems gibt es auch f√ºr DirectInput ein DirectInput-Objekt. Dieses unterst√ºtzt die IDirectInput7-COM-Schnittstelle, die √ºber die Methode <i>CreateDeviceEx</i> einen Zeiger auf <i>IDirectInputDevice7</i>-Ger√§te liefert. Das sind Eingabeger√§te die eigene Features mitbringen. Dazu z√§hlen Kn√∂pfe und Tasten mit Reglern, die eine Position im Raum repr√§sentieren, Mausr√§dchen oder Joysticks.</p>
		<p>Um DirectInput-Eingaben zu verarbeiten greifen Sie zun√§chst √ºber die <i>DirectInputCreateEx</i>-Funktion auf das <i>IDirectInput7</i>-Interface zu.</p>
		<p>Die mit einem Unterstrich gekenn&shy;zeichneten Variablen nehmen Sie als global an. Dabei handelt es sich um <i>Instance Variables</i>, die Ihren Programmen ebenso eigen sind wie den Variablen der angeforderten Eingabeger√§te.</p>
		<pre><code>
// DirectInput Interface
LPDIRECTINPUT7 _di;
HRESULT hr;
hr = DirectInputCreateEx(_hinst, DIRECTINPUT_VERSION,
	IID_IDirectInput7, (void**)&amp;_di, NULL);
if(FAILED(hr))
	return "geht nicht";
		</code></pre>
		<p>Nachdem Sie das <i>IDirectInput7</i>-Interface initialisiert haben, k√∂nnen Sie verschiedene <i>IDirectInputDevice7</i>-Objekte erzeugen lassen. Das bedeutet, dass Sie Zugriffe auf einzelne Eingabeger√§te anfordern k√∂nnen. Die wichtigsten sind <i>GUID</i> (Global Unique IDentifier = global eindeutige Nummer zur Identifi&shy;zierung):</p>
		<pre><code>
GUID_SysMouse,
GUID_SysKeyboard
GUID_Joystick
		</code></pre>
		<p>Unter Windows stehen Ihnen eine Maus und eine Tastatur zur Verf√ºgung. Ohne angeschlossene Tastatur bootet ein PC nicht, womit auch der Start von Windows entf√§llt. Startet Windows, bem√§ngelt es das Fehlen einer Maus.</p>
		<p>Den abgezogenen Joystick-Anschluss bem√§ngelt Windows hingegen nicht. Deshalb ist der Eintrag <i>GUID_Joystick</i> keine <i>Instance GUID</i>, sondern eine <i>Produkt GUID</i>. Wenn Sie einen Joystick mit <i>CreateDeviceEx</i> anfordern, m√ºssen Sie ber√ºck&shy;sichtigen, dass das Kontrollsystem von Windows keine eventuellen Fehler meldet.</p>
		<p>Wenn an einem PC mehrere M√§use oder Tastaturen angeschlossen sind, werden die Ger√§te zusammen&shy;gefasst. Sie k√∂nnen dann jede Maus oder Tastatur benutzen. DirectInput kennt noch weitere GUIDs:</p>
		<pre><code>
GUID_SysMouseEm,
GUID_SysMouseEm2,
GUID_SysKeyboardEm,
GUID_SysKeyboardEm2
		</code></pre>
		<p>Diese Eintr√§ge dienen nur Testzwecken, in unserem Beispiel setzen Sie sie nicht ein. Der Unterschied zu den in unserem Programm aufgerufenen Maus- und Tastatur-GUIDs ist, dass bei den Test-GUIDs alle Eingaben √ºber eine zus√§tzliche Emulations&shy;schicht laufen.</p>
		<p>Wenn Sie nicht wissen, welche Ger√§te sich an einem Rechner befinden oder welche installiert sind, k√∂nnen Sie nach ihnen suchen. Dabei hilft Ihnen die Methode</p>
		<pre><code>IDirectInput7::EnumDevices</code></pre>
		<p>Alle unterst√ºtzten Ger√§te dieser Art finden Sie in der Textbox auf S. 235.</p>
	</section>

	<aside>
		<h2>DIRECTINPUT MIT SEINEN DEVICE-TYPES</h2>
		<div>
			<pre><code>DIDEVTYPE_MOUSE
	DIDEVTYPEMOUSE_UNKNOWN
	DIDEVTYPEMOUSE_TRADITIONAL
	DIDEVTYPEMOUSE_FINGERSTICK
	DIDEVTYPEMOUSE_TOUCHPAD
	DIDEVTYPEMOUSE_TRACKBALL

DIDEVTYPE_KEYBOARD
	DIDEVTYPEKEYBOARD_UNKNOWN
	DIDEVTYPEKEYBOARD_PCXT
	DIDEVTYPEKEYBOARD_OLIVETTI
	DIDEVTYPEKEYBOARD_PCAT
	DIDEVTYPEKEYBOARD_PCENH
	DIDEVTYPEKEYBOARD_NOKIA1050
	DIDEVTYPEKEYBOARD_NOKIA9140
	DIDEVTYPEKEYBOARD_NEC98
	DIDEVTYPEKEYBOARD_NEC98LAPTOP
	DIDEVTYPEKEYBOARD_NEC98106
	DIDEVTYPEKEYBOARD_JAPAN106
	DIDEVTYPEKEYBOARD_JAPANAX
	DIDEVTYPEKEYBOARD_J3100

DIDEVTYPE_JOYSTICK
	DIDEVTYPEJOYSTICK_UNKNOWN
	DIDEVTYPEJOYSTICK_TRADITIONAL
	DIDEVTYPEJOYSTICK_FLIGHTSTICK
	DIDEVTYPEJOYSTICK_GAMEPAD
	DIDEVTYPEJOYSTICK_RUDDER
	DIDEVTYPEJOYSTICK_WHEEL
	DIDEVTYPEJOYSTICK_HEADTRACKER
DIDEVTYPE_HID</code></pre>
		</div>
	</aside>

	<section>
		<p>Geben Sie die folgenden Zeilen Code ein, um auf Maus oder Tastatur zuzugreifen:</p>
		<pre><code>
LPDIRECTINPUTDEVICE7 _mouse;
HRESULT hr;
hr = _di-&gt;CreateDeviceEx(GUID_SysMouse,
	IID_IDirectInputDevice7, (void**)&amp;_mouse, NULL);
if(FAILED(hr))
	return ‚Äûgeht nicht‚Äú

LPDIRECTINPUTDEVICE7 _keyboard;
hr = _di-&gt;CreateDeviceEx(GUID_SysKeyboard,
	IID_IDirectInputDevice7, (void**)&amp;_keyboard, NULL);
if(FAILED(hr))
	return ‚Äûgeht nicht‚Äú
		</code></pre>
		<p>Joystick-Ger√§te, die Sie nicht an jedem Rechner voraussetzen k√∂nnen, m√ºssen Sie mit der Syntax</p>
		<pre><code>IDirectInput7::EnumDevices</code></pre>
		<p>suchen. Wie bei allen Windows<i>Enum</i>-Methoden schreiben Sie eine Callback-Prozedur, die Sie mit der Syntax</p>
		<pre><code>IDirectInput7::EnumDevices</code></pre>
		<p>aufrufen. Als Parameter erh√§lt die Callback-Prozedur bei jedem Aufruf eine Beschreibung von einem gefundenen Eingabeger√§t, und Sie k√∂nnen sich eines davon ‚Äì sofern vorhanden ‚Äì aussuchen.</p>
		<p>Mit dem ersten Parameter von <i>IDirectInput7::EnumDevices</i> geben Sie an, welche Art von Eingabeger√§t Sie suchen: Joystick, Maus, Tastatur oder HID-Ger√§t. Sie k√∂nnen die Suche einschr√§nken, indem Sie die Flags (der letzte Parameter bei <i>IDirectInput7::EnumDevices</i> ) entsprechend setzen. Sie k√∂nnen ausschlie√ülich nach Force-Feedback-Ger√§ten suchen oder nach Ger√§ten, die gerade angeschlossen und nicht nur installiert sind.</p>
		<p>Das folgende Codebeispiel demonstriert, wie Sie einen ange&shy;schlossenen Joystick suchen und finden:</p>
		<pre><code>
LPDIRECTINPUTDEVICE7 _joy;
// Die Callback-Prozedur
BOOL CALLBACK EnumCallback
	(LPCDIDEVICEINSTANCE pdidInstance, LPVOID pvRef)
{
	// Interface holt Joystick
	HRESULT hr = _di-&gt;CreateDeviceEx
		(pdidInstance-&gt;guidInstance,
		IID_IDirectInputDevice7,pvRef), NULL);

	if(FAILED(hr))
		return DIENUM_CONTINUE;
	// Enumeration beenden
	return DIENUM_STOP;
}
...

//Suche ANGESCHLOSSENEN Joystick
hr = _di-&gt;EnumDevices(DIDEVTYPE_JOYSTICK,
	&amp;EnumCallback, (void**)&amp;_joy,
	DIEDFL_ATTACHEDONLY);
		</code></pre>
		<p>Das <i>DIEDFL_ATTACHEDONLY</i>-Flag setzt voraus, dass der Joystick korrekt angeschlossen ist. Wenn Sie zus√§tzlich Force-Feedback-F√§higkeit verlangen, verwenden Sie folgenden Aufruf:</p>
		<pre><code>
hr = _di-&gt;EnumDevices (DIDEVTYPE_JOYSTICK,
	&amp;EnumCallback, (void**)&amp;_joy,
	DIEDFL_ATTACHEDONLY | DIEDFL_FORCEFEEDBACK);
		</code></pre>
		<p>M√§use mit Force-Feedback-Eigenschaften rufen Sie so ab:</p>
		<pre><code>
LPDIRECTINPUTDEVICE7 _mausFF;
hr = _di-&gt;EnumDevices(DIDEVTYPE_MOUSE,
	&amp;EnumCallback, (void**)&amp;_mausFF,
	DIEDFL_FORCEFEEDBACK);

if(FAILED(hr))
	return ‚Äûgeht nicht‚Äú;
		</code></pre>
		<p>Damit haben Sie ein gew√ºnschtes Eingabeger√§t angefordert. Nun m√ºssen Sie den Ger√§ten noch mitteilen, wie Sie von ihnen Daten erhalten wollen. Dabei k√∂nnen Sie genau einstellen, wie und welche Daten Sie bei der Bewegung der Ger√§te bekommen. Sie teilen dieses DirectInput √ºber die Syntax folgender Methode mit:</p>
		<pre><code>IDirectInputDevice::SetDataFormat</code></pre>
		<p>Dabei l√∂nnen Sie das Datenformat komplett selbst definieren, indem Sie eine <i>DIDATAFORMAT</i>-Struktur f√ºllen und als Parameter √ºbergeben, oder Sie verwenden einfach eine der global vordefinierten Variablen:</p>
		<pre><code>
c_dfDIKeyboard
c_dfDIMouse
c_dfDIMouse2
c_dfDIJoystick
c_dfDIJoystick2
		</code></pre>
		<p>F√ºr unsere Zwecke gen√ºgen die vordefinierten Einstellungen, und so setzen Sie sie f√ºr unsere angeforderten Ger√§te ein:</p>
		<pre><code>
hr = _keyboard-&gt;SetDataFormat(&amp;c_dfDIKeyboard);
if(FAILED(hr))
	return false;

hr = _mouse-&gt;SetDataFormat(&amp;c_dfDIMouse2);
if(FAILED(hr))
	return false;

hr = _joy-&gt;SetDataFormat(&amp;c_dfDIJoystick2)
if(FAILED(hr))
	return false;
		</code></pre>
		<p>Nachdem Sie das Programmger√ºst so weit aufgebaut haben, m√ºssen Sie DirectInput mitteilen, in welchem Modus Sie die Ger√§te betreiben wollen. Dabei steht Ihnen der <i>DISCL_EXCLUSIVE</i>-Modus zur Auswahl, bei dem Sie anderen Applikationen keinen Zugriff mehr auf das von Ihnen in Beschlag genommene Eingabeger√§t zugestehen k√∂nnen, oder der <i>DISCL_NONEXCLUSIVE</i>-Modus. Wie der Namen verr√§t, ist der Zugriff anderer Anwendungen in diesem Modus gestattet. Die Einstellungen nehmen Sie mit folgender Methode vor:</p>
		<pre><code>IDirectInputDevice7::SetCooperativeLevel</code></pre>
		<p>Damit k√∂nnen Sie genau beeinflussen, wie Ihre Instanz des Eingabeobjekts mit eventuell vorhandenen anderen Instanzen und dem System interagiert. Sie k√∂nnen fordern, dass Ihre Anwendung im Vordergrund laufen muss, oder Sie deaktivieren die Windows-Taste. Der Aufruf sieht folgenderma√üen aus:</p>
		<pre><code>
hr = _keyboard-&gt;SetCooperativeLevel(_hwnd,
	DISCL_FOREGROUND | DISCL_NONEXCLUSIVE);
		</code></pre>
		<p>Nachdem Sie das <i>Coorperative Level</i> gesetzt haben, m√ºssen Sie das Eingabeger√§t vorbereiten und ihm mitteilen, dass Sie ab jetzt Daten bekommen wollen. Dies erledigen Sie mit der Syntax:</p>
		<pre><code>
IDirectInputDevice7::Acquire Methode:

hr= _keyboard.device-&gt;Acquire();
hr= _mouse.device-&gt;>Acquire();
hr= _joy.device-&gt;Acquire();
		</code></pre>
		<p>Damit sind die Vorarbeiten, das Eingabeger√§t anzusteuern, abgeschlossen, und Sie k√∂nnen die Daten abholen. Diese liegen im ger√§te&shy;spezifischen Format vor, das Sie entweder aus der vordefinierten Liste gew√§hlt oder selbst festgelegt haben. Dazu geben Sie beispielhaft ein:</p>
		<pre><code>_mouse-&gt;SetDataFormat(&amp;c_dfDIMouse2);</code></pre>
	</section>

	<aside>
		<h2>DATENFORMATE VON UND F√úR EINGABEGER√ÑTE</h2>
		<div>
			<table>
				<thead>
					<tr><th>Datenformat</th><th>Struktur mit Zustand</th></tr>
				</thead>
				<tbody>
					<tr><td>c_dfDIMouse</td><td>DIMOUSESTATE</td></tr>
					<tr><td>c_dfDIMouse2</td><td>DIMOUSESTATE2</td></tr>
					<tr><td>c_dfDIKeyboard</td><td>array of 256 bytes</td></tr>
					<tr><td>c_dfDIJoystick</td><td>DIJOYSTATE</td></tr>
					<tr><td>c_dfDIJoystick2</td><td>DIJOYSTATE2</td></tr>
				</tbody>
			</table>
		</div>
	</aside>

	<section>
		<figure class="floatright">
			<img src="assets/200008_2.jpg" width="800" height="600" alt="MIT DIESEN SCHALTKN√ñPFEN im Beispielprogramm sehen Sie Force-Feedback-Ger√§te in Aktion.">
			<figcaption><span>MIT DIESEN SCHALTKN√ñPFEN</span> im Beispielprogramm sehen Sie Force-Feedback-Ger√§te in Aktion.</figcaption>
		</figure>
		<p>In unserem Beispiel&shy;programm holen Sie mit einem Timer die jeweils aktualisierten Daten der einzelnen Eingabeger√§te in Intervallen von zehn Millisekunden ab. In einer Direct3D-Anwendung oder einem Spiel k√∂nnten Sie die Daten zum Beispiel auch nach jedem Frame, also nach jedem berechneten Bild, abholen. Dabei sollten Sie ber√ºck&shy;sichtigen, dass heutige 3D-Beschleuniger eventuell sehr hohe Frame-Raten schaffen. Mit weit √ºber 100 Bildern pro Sekunde werden die Zeitintervalle unn√∂tig klein. Bei zu kleinen Zeitinter&shy;vallen erhalten Sie zu viele redundante Daten, da DirectInput Ihnen den jeweiligen Ist-Zustand eines Eingabesystems liefert.</p>
		<p>Einige Eingabesysteme wie Joysticks sind <i>pollable devices</i>. Das hei√üt, dass Sie DirectInput informieren m√ºssen, bevor Sie aktualisierte Daten von einem dieser Ger√§te abholen. Der Befehl dazu</p>
		<pre><code>_joy.device-&gt;Poll()</code></pre>
		<p>wird von nicht <i>pollable devices</i> automatisch ignoriert.</p>
		<p>Die Methode</p>
		<pre><code>IDirectInputDevice::GetDeviceState()</code></pre>
		<p>holt die Daten ab. √úbergeben Sie ihr einen Zeiger auf eine Struktur, die die Daten aufnehmen soll, und die Gr√∂√üe dieser Struktur. Wenn Sie selbst definierte Datenformate gew√§hlt haben, m√ºssen Sie auch definieren, wie diese Struktur aussieht. F√ºr die vordefinierten Datenformate sehen Sie in der Tabelle unten den Namen der jeweils zugeh√∂rigen Struktur.</p>
		<p>Mit folgenden Zeilen lesen Sie die aktuellen Informationen eines Joysticks aus:</p>
		<pre><code>
HRESULT hr;
// Struktur f√ºr die Daten
DIJOYSTATE2 js2;
// Joystick-Info auslesen
hr = DIERR_INPUTLOST;
while(DIERR_INPUTLOST == hr)
{
	//Poll Befehl ausf√ºhren, um neue Daten auslesen zu k√∂nnen
	hr = _joy.device-&gt;Poll();

	// neue Daten auslesen
	hr = _joy.device-&gt;GetDeviceState(sizeof(DIJOYSTATE2), &amp;js2);
	if(hr == DIERR_INPUTLOST)
		if(FAILED( _joy.device-&gt;Acquire()))
		{
			_log( "inputWRAPPER_DX7: updateJOY :
				cannot GetDeviceState");
			return false;
		}
}
		</code></pre>
		<p>Als Beispiel greifen Sie die <i>DIJOYSTATE2</i>-Struktur heraus:</p>
		<pre><code>
typedef struct DIJOYSTATE2 {
	LONG lX; LONG lY; LONG lZ;
	LONG lRx; LONG lRy; LONG lRz;
	LONG rglSlider[2];
	DWORD rgdwPOV[4];
	BYTE rgbButtons[128];
	LONG lVX; LONG lVY; LONG lVZ;
	LONG lVRx; LONG lVRy;LONG lVRz;
	LONG rglVSlider[2];
	LONG lAX; LONG lAY; LONG lAZ;
	LONG lARx; LONG lARy;LONG lARz;
	LONG rglASlider[2];
	LONG lFX; LONG lFY; LONG lFZ;
	LONG lFRx; LONG lFRy;LONG lFRz;
	LONG rglFSlider[2];
} DIJOYSTATE2, *LPDIJOYSTATE2;
		</code></pre>
		<p>Das Listing macht deutlich, dass die Zeiten des simplen Atari Joysticks mit einem roten Knopf vorbei sind.</p>
	</section>

	<aside>
		<h2>DIE DIJOYSTATE2-STRUKTUR</h2>
		<div>
			<table>
				<thead>
					<tr><th>Syntax</th><th>Information</th></tr>
				</thead>
				<tbody>
					<tr><td>IX, IY, IZ</td><td>Joystick X, Y und Z Achse (meistens links/rechts, vorw√§rts/r√ºckw√§rts und Throttle-Funktion)</td></tr>
					<tr><td>lRx, lRy, lRz</td><td>Rotation der Achsen</td></tr>
					<tr><td>rglSlider[2]</td><td>Zwei zus√§tzliche Achsen (Slider)</td></tr>
					<tr><td>rgdwPOV[4]</td><td>Positionen von Richtungs-Controllern</td></tr>
					<tr><td>rgbButtons[128]</td><td>Array mit den Zust√§nden der Kn√∂pfe</td></tr>
					<tr><td>lVX, lVY, lVZ</td><td>Geschwindigkeit der Achsen</td></tr>
					<tr><td>lVRx, lVRy, lVRz</td><td>Winkelgeschwindigkeit der Achsen</td></tr>
					<tr><td>rglVSlider[2]</td><td>Geschwindigkeit zus√§tzlicher Achsen</td></tr>
					<tr><td>lAX, lAY, lAZ</td><td>Beschleunigung entlang der Achsen</td></tr>
					<tr><td>lARx, lARy, lARz</td><td>Winkelbeschleunigung entlang der Achsen</td></tr>
					<tr><td>rglASlider[2]</td><td>Beschleunigung an zus√§tzlichen Achsen</td></tr>
					<tr><td>lFX, lFY, lFZ</td><td>Kraft auf den Achsen</td></tr>
					<tr><td>lFRx, lFRy, lFRz</td><td>Drehmoment an den Achsen</td></tr>
					<tr><td>rglFSlider[2]</td><td>Kr√§fte an zus√§tzlichen Achsen</td></tr>
				</tbody>
			</table>
		</div>
	</aside>

	<section>
		<h2>Force Feedback mit DirectInput</h2>
		<figure class="floatright">
			<img src="assets/200008_3.jpg" width="640" height="539" alt="DEN FORCE-FEEDBACK-EDITOR finden Sie im DirectX Developer Kit.">
			<figcaption><span>DEN FORCE-FEEDBACK-EDITOR</span> finden Sie im DirectX Developer Kit.</figcaption>
		</figure>
		<p>Mit dem Force-Feedback-Effekt-Editor (Bestandteil des DirectX7 SDK) nutzen Sie die F√§higkeiten der Force-Feedback-Ger√§te. Mit diesem Editor k√∂nnen Sie eigene Effekte erzeugen und speichern. Sie k√∂nnen diese Dateien dann mit DirectInput laden und f√ºr Ihre Force-Feedback-Ger√§te nutzen.</p>
		<p>Laden Sie eine dieser Dateien, und holen Sie sich daraus die Effekte f√ºr den Joystick:</p>
		<pre><code>
FILE_EFFECT effects;
effects.device = _joy.device;
char filename[] = "test.ffe";
// Effekte Enumerieren im File und im Callback erzeugen
if(_joy.canREACT)
{
	if(FAILED(_joy.device-&gt;EnumEffectsInFile(file,
		EnumAndCreateEffectsCallback, &amp;effects, 0)))
		return false;
}
		</code></pre>
		<p>Um die Werte zu verarbeiten, ben√∂tigen Sie wieder eine Callback-Prozedur. Unsere Variante √ºberpr√ºft einfach, ob der angeschlossene Joystick die F√§higkeit mitbringt, einen Effekt abzuspielen, und f√ºgt ihn in diesem Fall in eine Liste ein.</p>
		<pre><code>
BOOL CALLBACK
	EnumAndCreateEffectsCallback(
	LPCDIFILEEFFECT fileEFFECT,
	LPVOID pvRef)
{
	HRESULT hr;
	LPDIRECTINPUTEFFECT effect = NULL;
	FILE_EFFECT* entry =
		reinterpret_cast&lt;FILE_EFFECT*&gt;(pvRef);
	// den File-Effekt anlegen
	if(FAILED(
		hr = entry-&gt;device-&gt;CreateEffect(
			fileEFFECT-&gt;GuidEffect,
			fileEFFECT-&gt;lpDiEffect,
			&amp;effect, NULL))
	)
		//effekt nicht wiederzugeben
		//n√§chster bitte
		return DIENUM_CONTINUE;

	// eine neue Effekt-Node anlegen
	EFFECT_NODE enode;
	enode.effect = effect;
	enode.repeats = 1;
	//in verkettete Liste einh√§ngen
	if(effect)
		entry-&gt;effects.push_back(enode);

	return DIENUM_CONTINUE;
}
		</code></pre>
		<p>Jetzt k√∂nnen Sie die geladenen Effekte, die Sie in der verketteten Liste gespeichert haben, ausgeben. Stoppen Sie alle eventuell schon laufenden Force-Feeback-Effekte:</p>
		<pre><code>
//Zeiger auf Effekt d.Liste:

FILE_EFFECT *feff = ...;
feff-&gt;device-&gt;SendForceFeedbackCommand(DISFFC_STOPALL);
		</code></pre>
		<p>Und so spielen Sie alle Effekte aus der Liste der Reihe nach ab:</p>
		<pre><code>
//eleganter Iterator:

std::vector&lt;EFFECT_NODE&gt;::iterator it;
for(it = feff-&gt;effects.begin(); it &lt; feff-&gt;effects.end(); it++)
	// und Effekt starten !
	(*it).effect-&gt;Start((*it).repeats, 0);
		</code></pre>
		<p>Mit diesem Instrumen&shy;tarium k√∂nnen Sie Ihre Eingabeger√§te umfassend nutzen. Damit spielen Sie auf allen Programm&shy;registern dieser Eingabeger√§te und ‚Äì dank Force Feedback ‚Äì auch Ausgabeger√§te. DirectInput ist eine der S√§ulen des DirectX-Systems und damit wesentlicher Bestandteil jedes Spiels, das auf DirectX basiert.</p>
	</section>


	<footer>
		<p>Erhard Thomas</p>
		<p>¬© 2000 WEKA Computerzeitschriften Verlag</p>
	</footer>
	</article>

	<nav class="pagenav">
		<a rel="prev" href="200007.html">7/2000</a>
		<a href="index.html">Inhalt</a>
		<a rel="next" href="200009.html">9/2000</a>
	</nav>
</body>
