<!DOCTYPE html>
<html lang="de">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="style.css">
	<title>Mathematische Reize (PC Underground, PC Magazin 2/2001)</title>
</head>
<body>
	<div class="credits">
		<h2>Dieser Artikel erschien erstmals im PC&nbsp;Magazin&nbsp;2/2001. Die Wieder&shy;ver√∂ffentlichung erfolgt mit freundlicher Genehmigung der <a rel="external nofollow noreferrer" href="https://wekanet.de">WEKA&nbsp;Media&nbsp;Publishing&nbsp;GmbH</a>.</h2>
	</div>

	<nav class="pagenav">
		<a rel="prev" href="200012.html">12/2000</a>
		<a href="index.html">Inhalt</a>
		<a rel="next" href="200103.html">03/2001</a>
	</nav>

	<article>
	<header>
		<h2>B√©zier- und Spline-Kurven</h2>
		<h1>Mathematische <span class="highlight">Reize</span></h1>
		<p class="summary">Wer als Anwender mit B√©zier-Kurven <span class="highlight">harmonische Rundungen</span> von Autoblechen am Rechner gestaltet, braucht keine h√∂here Mathematik. Programmierern bleibt sie nicht erspart.</p>
	</header>

	<section>
		<h3>Carsten Dachsbacher</h3>
		<p>Die steigende Rechenleistung moderner CPUs und die Entwicklung hochleist&shy;ungsf√§higer 3D-Grafikkarten haben dazu gef√ºhrt, dass pro&shy;fessionelles Modelling Einzug in Computerspiele gehalten hat. Die Grundlage f√ºr Modelling sind parametrische (glatte, gekr√ºmmte) Fl√§chen. Eine parametrische Fl√§che legen Sie durch Basis&shy;funktionen und St√ºtz-/Kontrollpunkte fest. Die Grundlagen f√ºr die Basis&shy;funktionen und deren Auswertung lesen Sie in diesem Beitrag. Zun√§chst zeichnen Sie Kurven. Deren Form ver√§ndern Sie durch die Position der St√ºtzpunkte. Mit diesem Handwerkszeug meistern Sie auch die Fl√§chen im drei&shy;dimensionalen Raum. F√ºr eine parametrische Kurve geben Sie ‚Äì wie bei Fl√§chen ‚Äì eine Reihe von Basis&shy;funktionen und St√ºtzpunkten an. Die B√©zier-Kurven sind die bekanntesten parametrischen Kurven. Sie wurden um 1960 entwickelt und in der franz√∂sischen Automobil&shy;industrie zum Karosserie&shy;design verwendet (Computer Aided Geometric Design, CAGD). Die Basis&shy;funktionen, die Sie bei B√©zier-Kurven verwenden, hei√üen Bernstein-Polynome.
		<img class="math" src="assets/200102_2.png" width="145" height="66" alt="Bernstein-Polynom"></p>
	</section>

	<aside>
		<h2>QUELLTEXTE</h2>
		<div>Die Quelltexte zu diesem Artikel finden Sie in der Datei  <a href="200102.zip">üíæ 200102.zip</a>.</div>
	</aside>

	<section>
		<figure class="floatright">
			<img src="assets/200102_3.png" width="338" height="586" alt="BERNSTEIN-POLYNOME sind die Basis der B√©zier-Kurven.">
			<figcaption><span>BERNSTEIN-POLYNOME</span> sind die Basis der B√©zier-Kurven.</figcaption>
		</figure>
		<p>Diese Funktionen besitzen drei Variablen:<br>
		‚Ä¢ <i>u</i> ist der Laufindex und nimmt Werte zwischen <i>0</i> und <i>1</i> an.<br>
		‚Ä¢ <i>n</i> ist eine Ganzzahl und gibt den Grad der Kurve an. Das ist zum einen die h√∂chste Potenz, in der die Laufvariable vorkommt, zum anderen bestimmen Sie dadurch die Zahl der St√ºtzpunkte.<br>
		‚Ä¢ Die B√©zier-Kurve hat <i>(n+1)</i> St√ºtzpunkte. F√ºr verschiedene Indizes <i>i</i> erhalten Sie verschiedene Funktionen (abh√§ngig von der Variablen <i>u</i>). Die Funktionswerte liegen im Intervall von [0,1]. Sie stellen die Gewichtung der einzelnen St√ºtzpunkte dar, was auch in der Formel f√ºr B√©zier-Kurven zu sehen ist.
		<img class="math" src="assets/200102_1.png" width="125" height="37" alt="B√©zier-Kurve"></p>
		<p>Der St√ºtzpunkt bi wird mit dem Bernstein-Polynom <i>i</i> vom Grad <i>n</i> multipliziert. Alle Punkte, die Sie f√ºr <i>u</i> zwischen <i>0</i> und <i>1</i> erhalten, liegen auf der B√©zier-Kurve. Nehmen Sie eine direkte Auswertung mit den Bernstein-Polynomen vor. Diese sieht wie folgt aus:</p>
		<pre><code>
// Koordinate d des Punkts abh√§ngig von u: d = F(u)
d.x = d.y = 0;
for (i = 0; i &lt; grad; i++)
{
	d = d + (b[i] * bernstein(u, i));
}

...

// wertet Bernstein-Polynom aus
double bernstein(double u,long i)
{
	return bin(grad, i) * pow(u, i) * pow(1.0-u, grad-i);
}

// berechnet Fakult√§t von n
double fac(long n) {
	double r = 1.0;
	for (i = 2; i &lt;= n; i++)
		r *= (double)i;
	return r;
}

// Binomialkoeffizient
double bin(long n, long k)
{
	return fac(n) / (Fac(n-k) * Fac(k));
}
		</code></pre>
		<figure class="floatright">
			<img src="assets/200102_4.png" width="392" height="310" alt="EINE B√âZIER-KURVE vom Grad <i>n=3</i> und dar√ºber das Kontrollpolygon als Linienzug zwischen den Kontrollpunkten">
			<figcaption><span>EINE B√âZIER-KURVE</span> vom Grad <i>n=3</i> und dar√ºber das Kontrollpolygon als Linienzug zwischen den Kontrollpunkten</figcaption>
		</figure>
		<p>Der Sourcecode <i>2dvector.c</i> zeigt eine definierte Vektorstruktur und √ºberladene Operatoren-Anwendung. Bevor Sie die B√©zier-Kurven genauer betrachten, verall&shy;gemeinern Sie die Formel zu einem beliebigen Intervall <i>[s,t]</i> f√ºr die Variable <i>u</i>:
		<img class="math" src="assets/200102_8.png" width="281" height="90" alt="B√©zier-Kurve"></p>
	</section>

	<section>
		<h2>Eigenschaften von B√©zier-Kurven</h2>
		<p>B√©zier-Kurven f√ºr <i>u</i> aus <i>[s,t]</i> liegen in der abge&shy;schlossenen konvexen H√ºlle. Die konvexe H√ºlle einer Punktmenge k√∂nnen Sie so veranschau&shy;lichen, dass Sie mit einer gespannten Schnur versuchen, alle Punkte einzuschn√ºren. Weiterhin k√∂nnen Sie sehen, dass die B√©zier-Kurve im ersten St√ºtzpunkt <i>b0</i> beginnt und im letzten <i>b3</i> endet (Endpunkt-Interpolation).</p>
		<p>Die Kurve endet nicht nur in den Endpunkten des Kontroll&shy;polygons, sie verl√§uft dort auch tangentiell an den Kanten der Kontroll&shy;polygone. Weiterhin sind B√©zier-Kurven <i>affin invariant</i> : Bei einer affinen Transformation (eine Drehung und/oder eine Verschiebung) der Kontrollpunkte wird die Kurve mittrans&shy;formiert, beh√§lt aber ihre Form.</p>
		<p>Die Kurve schwankt nicht st√§rker als ihr Kontroll&shy;polygon (<i>Variation-Diminishing-Property</i>, variations&shy;reduzierend). Sie zeichnen B√©zier-Kurven nicht punktweise, doch Sie werten die Bernstein-Polynome f√ºr jeden Punkt aus. Stattdessen approximieren Sie am Bildschirm die Kurve mit vielen Linien. Die Zahl der Linien h√§ngt von der Gr√∂√üe der Kurve auf dem Bildschirm und der Aufl√∂sung ab. Die Linien k√∂nnen Sie schneller zeichnen als die einzelnen Pixel, deren Position Sie rechenintensiv auswerten m√ºssten.</p>
	</section>

	<section>
		<h2>Der de-Casteljau Algorithmus</h2>
		<p>Ein schnellerer Auswerte-Algorithmus ‚Äì nicht f√ºr die Bernstein-Polynomen ‚Äì f√ºr die Punkte auf B√©zier-Kurven ist der de-Casteljau-Algorithmus. Er bestimmt die Koordinate eines Kurvenpunktes durch schrittweise Unterteilung des Kontroll&shy;polygons.</p>
		<p>Formal ben√∂tigen Sie folgende Definitionen, wobei Sie die Variablen wie folgt deuten k√∂nnen:
		<img class="math" src="assets/200102_5.png" width="229" height="115" alt="de-Casteljau"></p>
		<p>Den eigentlichen Clou beim de-Casteljau-Algorithmus mit dem Ziel, die Kurve schnell mit Linien zu approximieren, sehen Sie im rechten Teil des Bildes: Die Punkte, die Sie als Zwischen&shy;ergebnis am Rand der de-Casteljau-Pyramide erhalten, sind die Kontrollpunkte zweier neuer B√©zier-Kurven, die zusammen die bisherige Kurve ergeben. Mit einem Unterschied: Die neuen Kontroll&shy;polygone liegen n√§her an der tats√§chlichen B√©zier-Kurve. Wenn Sie also den de-Casteljau-Algorithmus rekursiv auf die neuen B√©zier-Kurven anwenden, erhalten Sie Kontroll&shy;polygone (Linienz√ºge), mit denen Sie die B√©zier-Kurve zeichnen. Der de-Casteljau-Algorithmus l√§sst sich effizient implementieren, wie Sie dem Codeausschnitt im Quellcode entnehmen. Dieser zeigt eine Mittelpunkts&shy;unterteilung (alpha=0.5).</p>
		<figure class="floatright">
			<img src="assets/200102_6.png" width="751" height="319" alt="DER DE-CASTELJAU-ALGORITHMUS wertet B√©zier-Kurven aus und teilt sie in diesem Beispiel.">
			<figcaption><span>DER DE-CASTELJAU-ALGORITHMUS</span> wertet B√©zier-Kurven aus und teilt sie in diesem Beispiel.</figcaption>
		</figure>
		<p>Wenn Sie Fl√§chen mit vielen Details modellieren wollen, m√ºssen Sie B√©zier-Kurven mit einem hohen Grad <i>n</i> verwenden. √Ñndern Sie den Ort eines Kontrollpunkts, √§ndern Sie damit die ganze Kurve. Das umgehen Sie, indem Sie mehrere B√©zier-Kurven von niedrigerem Grad (zum Beispiel kubisch, <i>n=3</i>) aneinander&shy;h√§ngen. Die Fl√§chen lassen sich leicht l√ºckenlos aneinander f√ºgen, da die Kurven am Endpunkt interpolierend sind. Entscheidend f√ºr die Darstellung ist auch die Steigung und Kr√ºmmung der Kurven an den Anschluss&shy;stellen. An einer Anschluss&shy;stelle entscheidet sich, ob Sie einen unerw√ºnschten Knick erhalten. Im Automobilbau gibt es eine weitere Anforderung: Die Kurven m√ºssen am Anschlusspunkt auch in der zweiten Ableitung gleich sein. Sonst ist der √úbergang bei Reflexionen, zum Beispiel auf Autolacken, sichtbar. Im unteren Teil des rechten Bildes auf der vorigen Seite sehen Sie die geometrischen Bedingungen, die zwei B√©zier-Kurven erf√ºllen m√ºssen, um den entsprechenden Anforderungen zu gen√ºgen. Trotz der etwas umst√§ndlichen Beschreibung detailreicher Fl√§chen haben sie aber trotzdem eine Existenz&shy;berechtigung: Rechner werten B√©zier-Kurven effizient und in Echtzeit aus. Damit haben B√©zier-Fl√§chen die Eigenschaften, die f√ºr Echtzeit-Rendering von Vorteil sind.</p>
		<figure class="large">
			<img src="assets/200102_7.png" width="999" height="689" alt="VERSCHIEDENE √úBERG√ÑNGE zweier B√©zier-Kurven und geometrische √úbergangsbedingungen perfektionieren die Kurven.">
			<figcaption><span>VERSCHIEDENE √úBERG√ÑNGE</span> zweier B√©zier-Kurven und geometrische √úbergangsbedingungen perfektionieren die Kurven.</figcaption>
		</figure>
	</section>

	<section>
		<h2>B-Spline-Kurven</h2>
		<figure class="floatright">
			<img src="assets/200102_12.png" width="347" height="499" alt="DIE B-SPLINE-BASISFUNKTIONEN sind nur in kleinen Bereichen von Null verschieden.">
			<figcaption><span>DIE B-SPLINE-BASISFUNKTIONEN</span> sind nur in kleinen Bereichen von Null verschieden.</figcaption>
		</figure>
		<p>B-Spline-Kurven sind eine neue Gattung mathematischer Kurven&shy;beschreibungen. Wir besch√§ftigen uns mit B-Spline-Kurven, die die Eigenschaft der affinen Invarianz (Begriff: siehe oben) mitbringen. Die Definition eine B-Spline-Kurve lautet:
		<img class="math" src="assets/200102_10.png" width="129" height="37" alt="Definition B-Spline"></p>
		<p>Die St√ºtzpunkte bezeichnen Sie mit <i>di</i> (de-Boor-Punkte, nach Carl de Boor). Zus√§tzlich gibt es einen Knotenvektor <i>t</i>, dessen Werte sich in den rekursiv definierten B-Spline-Basis&shy;funktionen niederschlagen:
		<img class="math" src="assets/200102_9.png" width="287" height="127" alt="Definition B-Spline Basisfunktionen"></p>
		<p>Im Bild oben rechts sehen Sie Basis&shy;funktionen vom Grad <i>0</i> bis <i>2</i>. Daran k√∂nnen Sie einen Vorteil gegen√ºber den Bernstein-Polynomen als Basis&shy;funktionen ablesen: Die B-Spline-Funktionen sind nur in einem begrenzten Bereich ungleich Null. Bernstein-Polynome sind im gesamten Bereich, in dem sich die Laufvariable <i>u</i> befindet, ungleich Null. Dies ist gleich&shy;bedeutend damit, dass ein Kontrollpunkt nur auf einem sehr begrenzten Bereich der Kurve Einfluss aus√ºbt. Damit k√∂nnen Sie an bestimmten Teilen eine B-Spline-Kurve detailreich modellieren, ohne die Kurve zu √§ndern.</p>
		<p>B-Spline-Basis&shy;funktionen vom Grad <i>n</i> sind st√ºckweise polynomiell (durch Polynome beschreibbar) und bieten deshalb optimale Glattheit. Dadurch werden die geometrischen √úbergangs&shy;bedingungen √ºberfl√ºssig. Um ein Gef√ºhl f√ºr die Auswirkungen des Knotenvektors auf die Kurve zu bekommen, experimen&shy;tieren Sie am besten mit unserem Beispiel&shy;programm. Der Knotenvektor hat so viele Werte wie Grad <i>n</i> plus Anzahl der St√ºtzpunkte plus 2. Der Knotenvektor beeinflusst den Verlauf der Kurve innerhalb der konvexen H√ºlle des Kontroll&shy;polygons. B-Spline-Kurven sind zum Beispiel nur Endpunkt&shy;interpolierend, wenn jeweils die ersten <i>(n+1)</i> und die letzten <i>(n+1)</i> Werte des Knotenvektors gleich sind.</p>
		<figure class="floatright">
			<img src="assets/200102_13.png" width="392" height="310" alt="EINE NORMALISIERTE B-Spline-Kurve und ihr Knotenvektor">
			<figcaption><span>EINE NORMALISIERTE</span> B-Spline-Kurve und ihr Knotenvektor</figcaption>
		</figure>
		<p>Die direkte Auswertung der B-Splines k√∂nnen Sie mit folgendem Codeausschnitt berechnen. Beachten Sie die Spezialf√§lle f√ºr den Knotenvektor bei der Rekursion im Listing <i>bspline.c</i>.</p>
		<p>Betrachten Sie eine B-Spline-Kurve vom Grad <i>n</i> mit <i>m</i> de-Boor-Punkten und einem Knotenvektor <i>t</i>. Nutzen Sie die folgenden Eigenschaften, um Kurven gezielt zu modellieren:<br>
		‚Ä¢ Fallen <i>n</i> de-Boor-Punkte zusammen (sind also identisch), so verl√§uft die Kurve durch diesen Punkt und liegt dort tangentiell an dem Kontroll&shy;polygon an. Damit k√∂nnen Sie Ecken in der Kurve modellieren.<br>
		‚Ä¢ Wenn Sie <i>n</i> de-Boor-Punkte auf einer Geraden platzieren, ber√ºhrt die Kurve diese Gerade. Wenn sich <i>(n+1)</i> Punkte auf einer Gerade befinden, liegt ein Abschnitt der Kurve auf dieser Geraden.<br>
		‚Ä¢ Fallen <i>n</i> Knoten (Werte im Knotenvektor) zusammen, also <i>t=ti</i> <i>+1=...=ti+n</i>, so gilt <i>F(t)=di</i>. Das hei√üt, dass die Kurve durch einen Kontrollpunkt verl√§uft und dort tangentiell am Kontroll&shy;polygon anliegt.<br>
		‚Ä¢ Als letzte Eigenschaft k√∂nnen Sie die ‚Äûlokale konvexe H√ºlle‚Äú ausnutzen. F√ºr ein <i>u</i> im Intervall <i>[ti, ti+1]</i> liegt die Kurve in der abge&shy;schlossenen konvexen H√ºlle der <i>(n+1)</i> vielen Kontrollpunkte <i>di-n, ..., di</i>.</p>
	</section>

	<section>
		<h2>Der de-Boor-Algorithmus</h2>
		<p>Auch f√ºr B-Spline-Kurven gibt es elegante Algorithmen zur Auswertung, die aber trotzdem rechen&shy;intensiver als die f√ºr B√©zier-Kurven sind. Als Pendant zum de-Casteljau-Algorithmus gibt es f√ºr B-Spline-Kurven den ‚Äì rekursiv definierten ‚Äì de-Boor-Algorithmus. Seine Definition:
		<img class="math" src="assets/200102_11.png" width="290" height="122" alt="de-Boor-Algorithmus"></p>
		<p>Um ihn anschaulich darzustellen, bedarf es einer anderen Darstellung der B-Spline-Kurve, der so genannten Polarform.</p>
		<p>Laut Definition gilt der de-Boor-Algorithmus nur f√ºr Parameter aus dem Intervall <i>[tj</i> <i>, tj+1</i> <i>]</i>. Folgender Programmcode berechnet den de-Boor-Algorithmus f√ºr die Kurve an der Stelle <i>u</i> vom Grad <i>l</i> im Intervall <i>[t(i), t(i+1)]</i>:</p>
		<pre><code>
//VECTOR deBoor(double u,long l,long i)
{
	if(l == 0)
	// letzte ausgewertete Stelle
	// im letzten Intervall !
		if(i == nKontrollPunkte)
			return d[nKontrollPunkte - 1];
		else
			return d[i];

	double t2 = (u - t[i])/ (t[i + grad + 1 - l] - t[i]);
	double t1 = 1.0 - t2;

	return deBoor(u, l-1, i-1)
		* t1 + deBoor(u, l - 1, i) * t2;
}
		</code></pre>
		<p>Wenn Sie eine Spline-Kurve an der Anzahl <i>steps</i> Stellen pro Intervall des Knotenvektors auswerten wollen, verwenden Sie folgenden Code:</p>
		<pre><code>
//Speicher ausreichend Punkte
VECTOR result[GENUGPUNKTE];
int nPunkte = 0;
// Kurvengrad n, ‚Äûsteps‚Äú-Stellen
// ‚ÄûnIntervals‚Äú im Knotenvektor
for(i = n; i &lt; nIntervals + n; i++)
{
// Vorraussetzung im de Boor Algorithmus
	if(t[i + 1 ] &gt; t[i])
	{
		for(j = 0; j &lt;= steps; j++)
		{
			double u = t[i] + (double)j *
				(t[i + 1] - t[i]) / (double)steps;

			result[nPunkte++] = deBoor(u, grad, i);
		}
	}
}
		</code></pre>
	</section>

	<footer>
		<p>Erhard Thomas</p>
		<p>¬© 2001 WEKA Computerzeitschriften Verlag</p>
		<p class="footnote"><b>Literatur:</b></p>
		<p class="footnote">Gerald Farin: Curvers and Surfaces for Computer Aided Geometric Design, Academic Press, ISBN 0-12-249054-1</p>
	</footer>
	</article>

	<nav class="pagenav">
		<a rel="prev" href="200012.html">12/2000</a>
		<a href="index.html">Inhalt</a>
		<a rel="next" href="200103.html">03/2001</a>
	</nav>
</body>
