<!DOCTYPE html>
<html lang="de">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="style.css">
	<title>Kleine Schritte zur gro√üen Grafik (PC Underground, PC Magazin 7/2003)</title>
</head>
<body>
	<div class="credits">
		<h2>Dieser Artikel erschien erstmals im PC&nbsp;Magazin&nbsp;7/2003. Die Wieder&shy;ver√∂ffentlichung erfolgt mit freundlicher Genehmigung der <a rel="external nofollow noreferrer" href="https://www.weka-media-publishing.de">WEKA&nbsp;Media&nbsp;Publishing&nbsp;GmbH</a>.</h2>
	</div>

	<nav class="pagenav">
		<a rel="prev" href="200306.html">6/2003</a>
		<a href="index.html">Inhalt</a>
		<a rel="next" href="200308.html">8/2003</a>
	</nav>

	<article>
	<header>
		<h2>Direct-3D-9</h2>
		<h1>Kleine Schritte zur <span class="highlight">gro√üen Grafik</span></h1>
		<p class="summary">Die Direct-3D-Komponente des vor kurzem vorgestellten DirectX 9 bietet <span class="highlight">eine einheitliche Schnittstelle</span>, um Grafik&shy;beschleuniger zu programmieren.</p>
	</header>

	<section>
		<h3>Carsten Dachsbacher</h3>
		<figure class="floatright">
			<img src="assets/200307_1.jpg" width="421" height="460" alt="Schichtenmodell: Die Bestandteile beim Rendering von 3D-Objekten.">
			<figcaption><span>Schichtenmodell:</span> Die Bestandteile beim Rendering von 3D-Objekten.</figcaption>
		</figure>
		<p>Das vor kurzem erschienene DirectX 9 enth√§lt ‚Äì neben den aktualisierten Komponenten DirectSound, DirectMusic etc. ‚Äì auch ein √ºberarbeitetes Direct3D-Interface, das die neueste Grafikhardware nutzen kann. Grund genug, Direct3D9 einen Platz in der Reihe der PC-Underground-Artikel zu reservieren.</p>
		<p>Wir zeigen Ihnen in dieser Ausgabe, wie Sie Direct3D9 sowohl f√ºr eine Fenster- als auch Vollbild-Anwendung korrekt initialisieren und verwenden. Damit legen Sie die Grundlage f√ºr weitere Programme und Grafikeffekte.</p>
		<p>F√ºr eine Direct3D-Anwendung ben√∂tigen Sie zun√§chst ein normales Windows-Fenster. Dieses k√∂nnen Sie mit den MFC (Microsoft Foundation Classes) anlegen, wenn Sie nicht einfach die Win32-API verwenden wollen. Wir haben den zweiten Weg gew√§hlt, da dieser einfacher zu √ºberschauen ist und weniger Overhead verursacht. Somit entsteht ein einfaches Framework f√ºr Direct3D-Anwendungen.</p>
	</section>

	<aside>
		<h2>QUELLTEXTE</h2>
		<div>Die Quelltexte zu diesem Artikel finden Sie in der Datei  <a href="200307.zip">üíæ 200307.zip</a>.</div>
	</aside>

	<section>
		<h2>Fenster auf</h2>
		<p>Wir zeigen Ihnen hier die vollst√§ndige <i>WinMain</i>-Funktion des Programms, in der Sie zun√§chst eine eigene Fensterklasse anlegen. Dazu f√ºllen Sie die Felder der <i>WNDCLASSEX</i>-Struktur aus. Darin sind alle Informationen √ºber den Stil, Cursor, Icon usw. der Fensterklasse enthalten. Unter anderem m√ºssen Sie auch einen Zeiger auf die Window-Prozedure angeben. Diese Funktion bearbeitet alle Nachrichten wie Mausklicks und Tastatur&shy;eingaben, die an ein Fenster verschickt werden. Das Beispiel&shy;programm fragt diesen Klick auf den <i>Schliessen</i>-Button des Fensters oder ein Dr√ºcken der <i>[Esc]</i>-Taste ab und verschickt gegebenenfalls eine <i>WM_QUIT</i>-Nachricht. Die Fensterklasse registrieren Sie dann mit <i>RegisterClassEx</i>:</p>
 		<pre><code>
int WINAPI WinMain(HINSTANCE hInst,
	HINSTANCE hPrevInst, LPSTR commandLine,
	int commandShow)
{
	WNDCLASSEX wndClass;
	MSG msg;

	// wndClass Struktur ausf√ºllen
	wndClass.lpszClassName = "PCUvsD3D9";
	wndClass.lpfnWndProc = WindowProc;
	...

	// Fensterklasse registrieren
	if(RegisterClassEx(&amp;wndClass) == 0)
		return E_FAIL;
</code></pre>
		<p>Wenn die Fensterklasse registriert ist, erzeugen Sie Ihr Direct3D-Fenster und bringen es auf den Bildschirm:</p>
		<pre><code>
gHWND = CreateWindowEx(NULL, "PCUvsD3D9",
	"Direct3D9",
	WS_OVERLAPPEDWINDOW | WS_VISIBLE,
	0, 0, 640, 480, NULL, NULL, hInst,
	NULL);

	if(gHWND == NULL)
		return E_FAIL;

	ShowWindow(gHWND, commandShow);
	UpdateWindow(gHWND);
		</code></pre>
		<p>Mit den folgenden Direct3D-Programmteilen verbinden Sie drei Funktionen, die initialiseren, rendern und die Ressourcen freigeben: <i>initialize3D(), render3D() und shutdown3D()</i>. Diese finden Sie im letzten Teil der <i>WinMain</i>-Funktion, die fortw√§hrend die Rendering-Funktion aufruft, bis Sie das Programm beenden:</p>
		<pre><code>
	// Initialisierung
	initialize3D();

	ZeroMemory(&amp;msg, sizeof(msg));

	// render3D(), bis zum Programmende
	while(msg.message != WM_QUIT)
	{
		if(PeekMessage(&amp;msg, NULL,
			0, 0, PM_REMOVE))
		{
			TranslateMessage(&amp;msg);
			DispatchMessage(&amp;msg);
		} else
			render3D();
	}

	// und aufr√§umen
	shutdown3d();

	UnregisterClass("MY_WINDOWS_CLASS",
		wndClass.hInstance);

	return msg.wParam;
}
		</code></pre>
		<p>Die obige <i>WinMain</i>-Funktion erzeugt ein Fenster. F√ºr eine Vollbild-Anwendung ist an dieser Stelle nur ein anderer <i>CreateWindowEx</i>-Aufruf notwendig:</p>
		<pre><code>
gHWND = CreateWindowEx(NULL, "PCUvsD3D9",
	"Direct3D9",
	WS_POPUP | WS_SYSMENU | WS_VISIBLE,
	0, 0, 640, 480, NULL, NULL, hInst, NULL);
		</code></pre>
		<figure class="large">
			<img src="assets/200307_2.jpg" width="800" height="252" alt="Rendering Pipeline: Nach diesem Schema arbeitet jeder Grafikbeschleuniger. Das aktuelle DirectX9 bleibt allerdings nur der neuesten Grafikhardware vorbehalten.">
			<figcaption><span>Rendering Pipeline:</span> Nach diesem Schema arbeitet jeder Grafikbeschleuniger. Das aktuelle DirectX9 bleibt allerdings nur der neuesten Grafikhardware vorbehalten.</figcaption>
		</figure>
	</section>

	<section>
		<h2>Direct3D im Fenster</h2>
		<p>Bei der Initialisierung von Direct3D mit der jeweiligen <i>init3d()</i>-Funktion sind die Unterschiede von Fenster- und Vollbild-Betrieb schon gr√∂√üer. Deshalb initialisieren Sie zuerst Direct3D f√ºr den Fenstermodus und anschlie√üend f√ºr Vollbild&shy;anwendungen.</p>
		<p>Als erstes erzeugen Sie sich mit <i>Direct3DCreate9(...)</i> eine Instanz eines <i>IDirect3D</i>-Objekts. Der Parameter lautet dabei immer <i>D3D_SDK_VERSION</i>. Dies dient dazu, f√ºr das Rendering Direct3D-Objekte zu erzeugen, deren F√§higkeiten auszulesen, Grafikmodi aufzulisten und die Parameter einzustellen. Achten Sie darauf, Fehler abzufragen, um einen Programm&shy;absturz zu vermeiden. In unserem Beispielcode √ºbernimmt dies die fiktive Funktion <i>error()</i>:</p>
		<pre><code>
LPDIRECT3D9 pD3D = NULL;
LPDIRECT3DDEVICE9 pD3DDevice = NULL;

pD3D = Direct3DCreate9(D3D_SDK_VERSION);

if(pD3D == NULL)
	error();
		</code></pre>
		<p>Da Sie im Fensterbetrieb keinen neuen Grafikmodus festlegen, lesen Sie die Parameter des aktuellen aus. Diese sind neben Breite, H√∂he und Bildwieder&shy;holfrequenz ein Format-Parameter, alles verpackt in eine <i>D3DDISPLAYMODE</i>-Struktur. Der Format-Parameter enth√§lt z.B. die Farbtiefe.</p>
		<pre><code>
D3DDISPLAYMODE dm;

if(FAILED(
	pD3D-&gt;GetAdapterDisplayMode(
		D3DADAPTER_DEFAULT, &amp;dm)))
	error();
		</code></pre>
		<p>Jetzt pr√ºfen Sie, ob das Direct3D-Ger√§t (Standard Device, identifiziert durch <i>D3DADAPTER_DEFAULT</i>) die Programm&shy;anforderungen erf√ºllen kann wie z.B. eine bestimmte Z-Buffer-Genauigkeit. Solche Format bezogenen Details fragen Sie mit <i>CheckDeviceFormat</i> ab:</p>
		<pre><code>
HRESULT hr;

hr = pD3D-&gt;CheckDeviceFormat(
	D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL,
	dm.Format, D3DUSAGE_DEPTHSTENCIL,
	D3DRTYPE_SURFACE, D3DFMT_D16);

if(hr == D3DERR_NOTAVAILABLE)
	error();
		</code></pre>
		<p>Der zweite Parameter (<i>D3DDEVTYPE_HAL</i>) steht f√ºr ein Hardware beschleunigtes Direct3D-Device. Sie k√∂nnten ihn z.B. durch <i>D3DDEVTYPE_REF</i> ersetzen, um den Software Referenz Rasterizer zu verwenden.</p>
		<p>Die F√§higkeiten einer Grafikkarte, die so genannten <i>Caps</i> (Capabilities) fassen Sie in einer <i>D3DCAPS9</i>-Struktur zusammen. Darin sind alle Features enthalten, deren umfangreiche Liste im DirectX9-SDK dokumentiert ist.</p>
		<pre><code>
D3DCAPS9 caps;
if(FAILED(pD3D-&gt;GetDeviceCaps(
	D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL,
	&amp;caps))
	error();
		</code></pre>
		<p>Die weiterhin ben√∂tigten Caps beschreiben, ob die Grafikkarte Vertex Processing (also Transformation, Beleuchtung usw.) in Hard- oder Software ausf√ºhrt. Diese Information verwenden Sie, um die <i>Behaviour Flags</i> zu setzen:</p>
		<pre><code>
DWORD flags;

if(caps.VertexProcessingCaps != 0)
	flags |= D3DCREATE_HARDWARE_VERTEXPROCESSING;
else
	flags |= D3DCREATE_SOFTWARE_VERTEXPROCESSING;
		</code></pre>
		<p>Als letzte Aufgabe der Initialisierung erzeugen Sie das Direct3D-Device. Dazu ben√∂tigen Sie noch die so genannten <i>Presentation Parameters</i>. Diese beschreiben z.B. die Anzahl der Backbuffers und deren Format oder das Z-Buffer-Format. Im Falle des Fenster&shy;betriebs, m√ºssen Sie nicht alle Parameter setzen:</p>
		<pre><code>
D3DPRESENT_PARAMETERS pp;
		</code></pre>
	</section>

	<section>
		<h2>Direct3D-Vollbild</h2>
		Die Initialisierung eines Vollbild-Direct3D-Modus unterscheidet sich prinzipiell in einem Punkt: Sie sind nicht darauf angewiesen, den gerade aktuellen Grafikmodus des Desktops zu verwenden, sondern Sie k√∂nnen sich einen Modus aussuchen. Dazu fordern Sie eine Liste aller unterst√ºtzten Grafikmodi an, die eine <i>D3DDISPLAYMODE</i>-Struktur beschreibt. Die Anzahl der Modi (hier mit 32-Bit-Farbtiefe, bestimmt durch <i>D3DFMT_</i> <i>X8R8G8B8</i>):
		<pre><code>
int nMaxModes = pD3D-&gt;GetAdapterModeCount(
	D3DADAPTER_DEFAULT, D3DFMT_X8R8G8B8);
		</code></pre>
		<p>Jetzt √ºberpr√ºfen Sie alle <i>nMaxModes</i>, bis Sie einen gew√ºnschten gefunden haben. Hierzu pr√ºfen Sie f√ºr jeden Modus die Breite, H√∂he, Bildwieder&shy;holfrequenz und die Format-Flags:</p>
		<pre><code>
D3DDISPLAYMODE dm;
bool foundMode = false;
....
if(foundMode == false)
	// kein passender Modus gefunden
	exit();
		</code></pre>
		<p>Der letzte Aspekt, den Sie beim Vollbild&shy;betrieb noch beachten m√ºssen, ist die Abfrage, ob f√ºr den gew√§hlten Grafikmodus Hardware-Beschleunigung zur Verf√ºgung steht. Die ersten beiden Parameter bezeichnen dabei wie gehabt das Direct3D-Device, gefolgt von den Formaten f√ºr Frame- und Back-Buffer und einem <i>FALSE</i> f√ºr Nicht-Fenster-Betrieb.</p>
		<pre><code>
if(FAILED(pD3D-&gt;CheckDeviceType(
	D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL,
	D3DFMT_X8R8G8B8...
		</code></pre>
		<p>Der Rest der Initialisierung, d.h. die √úberpr√ºfung der Caps, machen Sie so wie zuvor beschrieben.</p>
	</section>

	<section>
		<h2>Direct3D-Shutdown</h2>
		<p>Der Vollst√§ndig&shy;keit halber zeigen wir Ihnen an dieser Stelle, wie Sie Direct3D wieder korrekt verlassen. Dies beschr√§nkt sich lediglich auf zwei Aufrufe, die das Direct3D-Device und Objekt freigeben:</p>
		<pre><code>
void shutdown3D()
		</code></pre>
		<p>Nach der Initialisierung k√∂nnen Sie sich nun endlich der Rendering Schleife Ihres Programms widmen, die Sie in der <i>render3D()</i>-Funktion implementieren. Diese ist fest nach Schema aufgebaut: Als erstes l√∂schen Sie den Frame-, Depth- und/oder Stencil-Buffer, je nach dem, was Sie f√ºr das Device angefordert haben. Wenn Sie jeweils den ganzen Buffer l√∂schen wollen, sind die ersten beiden Parameter <i>0</i> bzw. <i>NULL</i>. Welcher Buffer betroffen ist, legen Sie im dritten Parameter durch eine <i>Oder</i>-Verkn√ºpfung der <i>D3DCLEAR</i>-Flags fest.</p>
		<p>Die Farb-, Tiefen- und Stencil-Werte, welche die Buffers beschreiben, bilden die letzten drei Parameter:</p>
		<pre><code>
pD3DDevice-&gt;Clear(0, NULL,
	D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER,
	D3DCOLOR_COLORVALUE(0, 1, 0, 1), 1.0f, 0);
		</code></pre>
		<p>Alle folgenden Rendering-Vorg√§nge befinden sich zwischen den <i>BeginScene</i>- und <i>EndScene</i>-Aufrufen:</p>
		<pre><code>
pD3DDevice-&gt;BeginScene();
// Rendering !
pD3DDevice-&gt;EndScene();
		</code></pre>
		<p>Zuletzt bringen Sie den Inhalt des Backbuffers, also das Resultat des Renderings auf den Bildschirm. Da Sie auch hier jeweils den ganzen Buffer sehen wollen, sind alle Parameter <i>NULL</i>:</p>
		<pre><code>
pD3DDevice-&gt;Present (NULL, NULL, NULL, NULL);
		</code></pre>
	</section>

	<section>
		<h2>Transformationen</h2>
		<p>F√ºr das Rendering ben√∂tigen Sie Trans&shy;formationen, die Sie √ºber die <i>SetTransform</i>-Methode Ihres Direct3D-Device setzen. Es gibt eine Transformation (definiert durch eine 4x4 Matrix) f√ºr die 3D-2D-Projektion (<i>D3DTS_PROJECTION</i>), eine Kamera-Abbildung (<i>D3DTS_</i> <i>VIEW</i>) und die so genannte World-Transformation (<i>D3DTS_WORLD</i>), die die Transformation eines Objektes in den World Space angibt.</p>
		<p>Zwar gibt es mehrere dieser World Matrizen, um Vertex Blending bei Animationen zu verwenden, doch bleibt das f√ºr unseren Einsatz zun√§chst nebens√§chlich. Die Trans&shy;formationen bilden nur einen kleinen Teil der Rendering Pipeline und sind f√ºr die <i>Fixed Function-Pipeline</i> relevant. Dieser Teil √ºbernimmt die normale Trans&shy;formations- und Beleuchtungs&shy;berechnung.</p>
		<p>Um solche Trans&shy;formationen elegant zu handhaben, verwenden Sie am besten die Direct3D-Erweitungen (<i>D3DX</i>). <i>D3DX</i> sammelt umfangreiche Direct3D-Hilfsroutinen f√ºr vielf√§ltige Zwecke wie f√ºr Mathematik und Texturen. Darin ist u.a. der <i>D3DXMATRIX</i>-Typ definiert, der eine 4x4-Matrix darstellt. Au√üerdem verf√ºgen Sie damit √ºber zahlreiche Methoden, um Matrizen zu erzeugen und zu berechnen. Um eine Matrix f√ºr eine perspek&shy;tivische Abbildung zu erhalten, platzieren Sie die folgenden Code-Fragment in der Render-Schleife:</p>
		<pre><code>
D3DXMATRIX mProjection;
		</code></pre>
		<p>F√ºr die World Matrizen k√∂nnen Sie z.B. die Funktionen <i>D3DXMatrixTranslation /</i> <i>D3DXMatrixRotationAxis</i> verwenden, um Abbildungen zu verschieben oder zu drehen. Die Kamera-Matrix erzeugen Sie intuitiv mit <i>D3DXMatrixLookAtLH</i>.</p>
	</section>

	<section>
		<h2>Rendering Primitive</h2>
		<p>Jetzt haben Sie eine vollst√§ndige Umgebung geschaffen, um geometrische Primitive zu rendern. Damit sind Punkte, Linien, Dreiecke usw. gemeint. Die von Direct3D unterst√ºtzten Primitive sehen Sie im Bild.</p>
		<figure class="large">
			<img src="assets/200307_4.jpg" width="654" height="347" alt="Auswahl: Die Direct3D-Rendering Primitive berechnen Sie mit vergleichsweise einfacher Matrizen-Mathematik.">
			<figcaption><span>Auswahl:</span> Die Direct3D-Rendering Primitive berechnen Sie mit vergleichsweise einfacher Matrizen-Mathematik.</figcaption>
		</figure>
		<p>Am besten rendern Sie mit den so genannten Vertex Buffers. Unter einem Vertex Buffer k√∂nnen Sie sich einen Speicher&shy;bereich vorstellen, der nur Vertex Daten wie z.B. die Eckpunkte eines Dreiecksnetzes und damit assoziierte Daten enth√§lt. Das Format der Vertices kann dabei sehr unterschied&shy;lich sein: untrans&shy;formiert, transformiert, beleuchtet oder nicht, mit oder ohne Textur-Koordinaten usw. Das Format beschreiben Sie √ºber das <i>Flexible Vertex Format</i> (FVF). Die m√∂glichen Vertex-Attribute sehen Sie in der Tabelle.</p>
		<p>Um einen Vertex Buffer anzulegen, legen Sie zun√§chst das Format fest und erzeugen entsprechende Daten (hier zum Beispiel mit einem konstanten Array), indem Sie eine Vertex-Struktur und die dazugeh√∂rigen <i>FVF</i>-Flags (eine Kombination der <i>D3DFVF</i>-Konstanten) definieren:</p>
		<pre><code>
#define FVF_VERTEX3D (D3DFVF_XYZ | D3DFVF_DIFFUSE)
		</code></pre>
		<p>W√§hrend der Initialisierung von Direct3D erzeugen Sie den Vertex Buffer:</p>
		<pre><code>
LPDIRECT3DVERTEXBUFFER9 pDreieckVB;
		</code></pre>
		<p>Der erste Parameter gibt die Gr√∂√üe des Vertex Buffers in Bytes an. Mit dem zweiten Parameter k√∂nnen Sie so genannte <i>D3DUSAGE</i>-Parameter spezifizieren, z.B. um den Vertex Buffer <i>write-only</i> zu deklarieren. Sie sollten die F√§higkeiten eines Vertex Buffers immer so weit wie m√∂glich einschr√§nken, um eine gr√∂√ütm√∂gliche Performance zu erzielen! Der n√§chste Parameter gibt Auskunft √ºber das <i>FVF</i>, gefolgt von einer <i>D3DPOOL</i>-Konstante, die bestimmt, in welchem Speicher&shy;bereich (z.B. Haupt-oder Grafikkarten-Speicher) der Vertex Buffer abgelegt wird. Wenn Sie daf√ºr die Funktion <i>D3DPOOL_MANAGED</i> w√§hlen, k√∂nnen Sie nichts falsch machen: Direct3D k√ºmmert sich um die Daten, platziert Sie am sinnvollsten und beh√§lt ein Backup im Systemspeicher. Der vorletzte Parameter ist ein Zeiger auf das Vertex Buffer Interface, das mit dem Vertex Buffer assoziiert ist. Der letzte Parameter ist immer <i>NULL</i>.</p>
		<p>Nun k√∂nnen Sie Ihre Daten in den Vertex Buffer kopieren. Dazu m√ºssen Sie diesen verschlie√üen (lock). Sie erhalten einen Zeiger auf einen Speicher&shy;bereich, in den Sie die Daten schreiben:</p>
		<pre><code>
VERTEX3D *pData = NULL;
		</code></pre>
		<p>Nachdem Sie die obigen Schritte w√§hrend der Initialisierung vorgenommen haben, k√∂nnen Sie in der Render-Schleife das Dreieck auf den Bildschirm bringen. Dazu m√ºssen Sie Direct3D zwei Dinge ‚Äì jeweils vor dem Rendering-Kommando ‚Äì mitteilen: Wo sind die Daten, also welcher Vertex Buffer wird gerade verwendet, und welches Format haben die Daten?</p>
		<p>Das Rendering Kommando lautet dann f√ºr ein Primitiv ab der Position <i>0</i> im Vertex Buffer:</p>
		<pre><code>
pD3DDevice-&gt;DrawPrimitive(D3DPT_TRIANGLELIST, 0, 1);
		</code></pre>
		<p>In der <i>shutdown3D()</i>-Funktion geben Sie die Ressourcen des Vertex Buffers bei Programmende wieder frei. Dies muss erfolgen, bevor Sie das Direct3D-Device freigeben:</p>
		<pre><code>
pDreieckVB-&gt;release();
		</code></pre>
	</section>

	<section>
		<h2>Render States</h2>
		<figure class="floatright">
			<img src="assets/200307_3.jpg" width="544" height="445" alt="Render States: einfaches Modifizieren des Rendering">
			<figcaption><span>Render States:</span> einfaches Modifizieren des Rendering</figcaption>
		</figure>
		<p>Wie Sie vielleicht von OpenGL wissen, gibt es eine riesige Anzahl von so genannten Render States: Zust√§nde bzw. Variablen, deren Wert das Rendering beeinflusst. Zum Beispiel <i>Culling Modi</i>, Z-Buffer oder Alpha Tests, Beleuchtungs&shy;parameter usw. Alle diese Einstellungen sind in Direct3D in der <i>SetRenderState</i>-Methode des Direct3D-Device Objektes zusammen&shy;gefasst. Diese Methode akzeptiert zwei Parameter: Der erste gibt an, welchen <i>State (D3DRS</i>-Konstante) Sie modifizieren wollen, gefolgt von einem Wert. Dieser kann dabei entweder ein numerischer Wert oder eine vordefinierte Konstante sein. S√§mtliche Render States listet wiederum das DirectX-SDK auf.</p>
		<p>Unser Beispiel&shy;programm verwendet die Render States z.B., um zwischen dem Rendering von ausgef√ºllten Dreiecken und Dreieckskanten zu w√§hlen:</p>
		<pre><code>
// ausgef√ºllt
pD3DDevice-&gt;SetRenderState(
	D3DRS_FILLMODE, D3DFILL_SOLID);
pD3DDevice-&gt;SetRenderState(.....
		</code></pre>
		<figure class="floatright">
			<img src="assets/200307_5.jpg" width="502" height="440" alt="Alpha Blending: Farbeffekte durch Akkumulation der Farbwerte">
			<figcaption><span>Alpha Blending:</span> Farbeffekte durch Akkumulation der Farbwerte</figcaption>
		</figure>
		<p>Mit den Render States f√ºr Alpha Blending erzeugt unser Beispiel&shy;programm weitere interessante Effekte.</p>
		<p>Ein Direct3D-Device kann sich entweder im <i>Betriebs&shy;zustand</i> oder im <i>Lost State</i> befinden. Letzteres tritt z.B. ein, wenn einer Vollbild-Anwendung der Fokus (z.B. durch Dr√ºcken von <i>Alt-Tab</i>) entzogen wird oder auch durch Power Management Funktionen. Im Lost State haben Rendering Kommandos keinen Effekt, obwohl Sie <i>D3D_OK</i> als R√ºckgabewert liefern. Der Lost State ist nur am <i>D3DERR_DEVICELOST</i>-R√ºckgabewert der <i>Present(...)</i>-Methode zu erkennen.</p>
	</section>

	<section>
		<h2>Lost Devices</h2>
		<p>Dieses Ereignis m√ºssen Sie in Ihrem Programm abfragen und warten, bis das Device wiederher&shy;gestellt werden kann. Anschlie√üend sind alle Ressources im Video-Speicher freizugeben und neu zu erzeugen. Der ben√∂tigte Programmcode f√ºr die Wiederher&shy;stellung ist dabei √§hnlich oder sogar identisch, um Vertex Buffers und anderer Ressourcen zu initialisieren. Dieser Vorgang ist aber nicht notwendig, wenn Sie die Ressourcen mit <i>D3DPOOL_MANAGED</i> angelegt haben. Deshalb k√∂nnen wir die detaillierte Behandlung der Lost Devices zun√§chst au√üen vor lassen.</p>
		<p>Mit dem Beispiel&shy;programm haben Sie so die Grundlagen geschaffen, um saubere Direct3D-Programme zu entwickeln, die die Leistung Ihrer Grafikkarte aussch√∂pfen k√∂nnen. Es dient als Basis f√ºr weitere PC-Underground-Programme, welche Sie schrittweise ausbauen.</p>
	</section>

	<aside>
		<h2>Flexible Vertex-Formats</h2>
		<div>
			<table>
				<thead>
					<tr><th>Vertex-Attribut</th><th>transformierte/untransformiert Vertices</th><th>Daten</th></tr>
				</thead>
				<tbody>
					<tr><td>Vertex Position</td><td>‚úî / ‚úî</td><td>X, Y, Z (Float)</td></tr>
					<tr><td>RHW</td><td>‚úî / -</td><td>RHW (Float)</td></tr>
					<tr><td>Blending Gewichte</td><td>‚úî / ‚úî</td><td>1, 2 oder 3 Floats/DWORD</td></tr>
					<tr><td>Vertex Normale</td><td>- / ‚úî</td><td>Nx, Ny, Nz (Float)</td></tr>
					<tr><td>Vertex Punktgr√∂√üe</td><td>‚úî / ‚úî</td><td>1 Float</td></tr>
					<tr><td>Farbe Diffus</td><td>‚úî / ‚úî</td><td>RGBA (DWORD)</td></tr>
					<tr><td>Farbe Spekular</td><td>‚úî / ‚úî</td><td>RGBA (DWORD)</td></tr>
					<tr><td>8x Textur Koordinaten</td><td>‚úî / ‚úî</td><td>1 bis 4 Floats</td></tr>
				</tbody>
			</table>
		</div>
	</aside>

	<footer>
		<p>Erhard Thomas</p>
		<p>¬© 2003 WEKA Computerzeitschriften Verlag</p>
	</footer>
	</article>

	<nav class="pagenav">
		<a rel="prev" href="200306.html">6/2003</a>
		<a href="index.html">Inhalt</a>
		<a rel="next" href="200308.html">8/2003</a>
	</nav>
</body>
