<!DOCTYPE html>
<html lang="de">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="style.css">
	<title>Schnellster im Ziel (PC Underground, PC Magazin 8/2001)</title>
</head>
<body>
	<div class="credits">
		<h2>Dieser Artikel erschien erstmals im PC&nbsp;Magazin&nbsp;8/2001. Die Wieder&shy;ver√∂ffentlichung erfolgt mit freundlicher Genehmigung der <a rel="external nofollow noreferrer" href="https://www.weka-media-publishing.de">WEKA&nbsp;Media&nbsp;Publishing&nbsp;GmbH</a>.</h2>
	</div>

	<nav class="pagenav">
		<a rel="prev" href="200107.html">7/2001</a>
		<a href="index.html">Inhalt</a>
		<a rel="next" href="200109.html">9/2001</a>
	</nav>

	<article>
	<header>
		<h2>Der A*-Algorithmus</h2>
		<h1><span class="highlight">Schnellster</span> im Ziel</h1>
		<p class="summary">Mit dem <i>A*</i>-Algorithmus suchen Sie in Computerspielen den <span class="highlight">optimalen Pfad f√ºr Ihre Spielfiguren</span>. Lernen Sie die Methoden der Echtzeit-Strategiespiele kennen!</p>
	</header>

	<section>
		<h3>Carsten Dachsbacher</h3>
		<p>Lernen Sie den <i>A*</i>-Algorithmus (gesprochen: A-Stern) kennen. Dieser Algorithmus findet seit 1968 in der K√ºnstlichen Intelligenz (KI) und in akademischen Suchsystemen Anwendung.</p>
		<p>Der <i>A*</i>-Algorithmus l√∂st die Grundaufgabe der meisten Computerspiele: Sie planen damit einen Pfad, auf dem sich eine Spielfigur in Computer&shy;spielen bewegen soll. In der Spiele-KI neuerer Computerspiele, vor allem aus dem Echtzeit-Genre, tritt diese Situation h√§ufig auf. Meist wird der Weg einer Figur berechnet, die sich auf einer Spielkarte zu einem vom Spieler gew√§hlten Ziel bewegen soll.</p>
		<p>Mit Hilfe des <i>A*</i>-Algorithmus k√∂nnen Sie Hindernissen ausweichen. Au√üerdem soll die Spielfigur die Gegebenheiten der Spielterrains bestm√∂glich ausnutzen. Der Spielheld soll also einen schlammigen Sumpf oder einen steilen Berg vermeiden und lieber auf Stra√üen oder freiem Gel√§nde laufen.</p>
	</section>

	<aside>
		<h2>QUELLTEXTE</h2>
		<div>Die Quelltexte zu diesem Artikel finden Sie in der Datei  <a href="200108.zip">üíæ 200108.zip</a>.</div>
	</aside>

	<section>
		<h2>Grundlagen: das Zahlenschiebepuzzle</h2>
		<figure class="floatright">
			<img src="assets/200108_1.png" width="455" height="537" alt="DAS ZAHLENPUZZLE ist ein Paradebeispiel f√ºr den A*-Algorithmus.">
			<figcaption><span>DAS ZAHLENPUZZLE</span> ist ein Paradebeispiel f√ºr den A*-Algorithmus.</figcaption>
		</figure>
		<p>Der <i>A*</i>-Algorithmus ist ein Graph-Such&shy;algorithmus. Ein Graph besteht aus Knoten, die durch Kanten verbunden sind. Dieser Graph ist implizit definiert, wie im Folgenden erkl√§rt: Zu einem Knoten sind die Knoten angegeben, die durch Kanten direkt erreichbar sind. Eine explizite Definition w√ºrde die Adjazenz&shy;information (die Verbindungs&shy;information) von jedem Knoten zu jedem anderen speichern. Ein Knoten dieses Graphs entspricht einem Zustand in unserer <i>A*</i>-Suche. Was Sie suchen, spielt keine Rolle. Es geht nur darum, einen L√∂sungsweg darzustellen. Der <i>A*</i>-Algorithmus sucht f√ºr Sie den besten Pfad von einem gegebenen Start- zu einem gew√ºnschten Endzustand. Dabei l√§uft er durch den Graphen und untersucht die Nachbarknoten der besuchten Zust√§nde.</p>
		<p>Ein bekanntes Spiel ‚Äì und gern vorgef√ºhrtes Beispiel f√ºr den <i>A*</i>-Algorithmus ‚Äì ist das 8er Zahlen&shy;schiebepuzzle. Dieses bringt in einem 3 x 3 Feld die Ziffern 1 bis 8 unter. Die Ziffern k√∂nnen Sie verschieben. Der Graph erreicht einen neuen Zustand, wenn Sie eine Ziffer verschieben. Diesen L√∂sungsweg des Zustands&shy;graphen zeigt das Bild unten.</p>
		<p>Mit dem <i>A*</i>-Algorithmus k√∂nnen Sie auch den Pfad einer Spielfigur in einer virtuellen Welt planen. Der aktuelle Zustand entspricht in diesem Fall der momentanen Position der Spielfigur. Erreichbare Zust√§nde entsprechen in diesem Beispiel Spielfeldern, die die Figur durch einen Bewegungszug erreichen kann.</p>
		<p>Der <i>A*</i>-Algorithmus untersucht immer wieder den Zustand, der voraus&shy;sichtlich zum optimalen Pfad geh√∂rt. Der Algorithmus untersucht dazu die Knoten des Graphen, die er noch nicht erforscht hat. Zuerst √ºberpr√ºft er, ob es sich schon um das Ziel handelt. In diesem Fall ist die Suche beendet. Sonst notiert der <i>A*</i>-Algorithmus alle Nachbar&shy;zust√§nde des gerade untersuchten Zustands, um sie sp√§ter zu betrachten.</p>
		<p>Der <i>A*</i>-Algorithmus speichert zwei Listen von Zust√§nden: die <i>Open</i>- und die <i>Closed</i>-Liste f√ºr unerforschte und erforschte Zust√§nde. Zu Beginn der Suche ist die <i>Closed</i>-Liste leer. Die <i>Open</i>-Liste enth√§lt nur einen Startzustand: die aktuelle Position der Spielfigur. Der <i>A*</i>-Algorithmus sucht sich wiederum den besten Zustand aus der <i>Open</i>-Liste, um ihn zu untersuchen und entfernt ihn daraus. Danach werden alle Nachbar&shy;zust√§nde erzeugt. Nun m√ºssen Sie unterscheiden: Sind diese Zust√§nde neu, werden sie an die <i>Open</i>-Liste angeh√§ngt.</p>
	</section>

	<section>
		<h2>Schnellster Weg aus dem Labyrinth</h2>
		<figure class="floatright">
			<img src="assets/200108_5.jpg" width="390" height="390" alt="DER A*-ALGORITHMUS findet auch Wege durch ein Labyrinth.">
			<figcaption><span>DER A*-ALGORITHMUS</span> findet auch Wege durch ein Labyrinth.</figcaption>
		</figure>
		<p>Befinden sich Zust√§nde schon in der <i>Open</i>-Liste, dann wird ‚Äì falls ein besserer Weg gefunden wurde ‚Äì die Information dort neu gespeichert. Zust√§nde in der <i>Close</i>-Liste f√ºr die der Algorithmus einen besseren Weg findet, nimmt er aus dieser Liste und f√ºgt sie neu in die <i>Open</i>-Liste ein. Denn das k√∂nnte einen besseren Weg er√∂ffnen. Das Suchen und Eintragen der Nachbar&shy;zust√§nde hei√üt <i>Expansion eines Knotens</i>. Wenn die <i>Open</i>-Liste leer ist, bevor der Endzustand erreicht wird, gibt es keinen Pfad vom Start- zum Endzustand.</p>
		<p>Um den besten Zustand zu w√§hlen, betrachten Sie zun√§chst die Struktur, um einen Zustand zu speichern:</p>
		<pre><code>
class Position
{
private:
	int _x, _y;
	Position neighbour(const int d);
...
};

class Node
{
friend class AStar;
private:
	int g, h, f;
	Node *pred;
	int nPred;
	Position p;
...
};
		</code></pre>
		<p>Die Klasse <i>Position</i>, verwenden Sie, um einfacher 2D-Integer-Koordinaten zu speichern. Die Klasse bietet neben Zugriffs&shy;methoden so genannte <i>√ºberladene</i> Operatoren, um den Umgang mit Koordinaten zu erleichtern. Die Methode</p>
		<pre><code>Position::Position neighbour(const int d)</code></pre>
		<p>liefert die Position eines Nachbarknotens.</p>
		<p>In der <i>Node</i>-Klasse speichern Sie die Daten eines Zustandes. Die Klasse enth√§lt die aufsummierten Kosten des besten Wegs vom Startzustand bis zum aktuellen Knoten <i>g</i> und die gesch√§tzten Restkosten zum Ziel <i>h</i>.</p>
		<p>Weiterhin speichern Sie <i>f</i>, die Summe aus <i>g</i> und <i>h</i>, einen Zeiger auf den Vorg√§nger-Zustand und einen weiteren Zeiger auf der verketten Liste der Zust√§nde <i>*pred</i>. Sie schreiben auch die Zahl der Vorg√§nger <i>nPred</i> und die Position des Knotens in der virtuellen Welt <i>p</i> in den Arbeits&shy;speicher. Die <i>Kosten</i> bezeichnen damit den Aufwand, den die Spielfigur h√§tte, wenn sie den betrachteten Weg gehen w√ºrde. In einem Knoten sind in <i>g</i> die Kosten des optimalen Pfads vom Startzustand zu diesem Knoten gespeichert. Dieser Pfad ist <i>nPred</i> Knoten lang. Sie k√∂nnten ihn jederzeit zur√ºck&shy;verfolgen, indem Sie den <i>*pred</i>-Zeigern folgen.</p>
		<p>Nun gilt es, die Kosten zu berechnen oder zu sch√§tzen. Die Kosten vom Startzustand bis zum aktuellen Knoten k√∂nnen Sie exakt berechnen. Sie ben√∂tigen dazu nur eine Funktion, die Ihnen die Kosten liefert, wenn Sie Ihre Spielfigur von einem Feld zum n√§chsten bewegen w√ºrden. Die Restkosten <i>h</i> m√ºssen Sie sch√§tzen.</p>
		<p>Den restlichen Weg haben Sie noch nicht untersucht. Den wollen Sie ja erst berechnen. Der <i>A*</i>-Algorithmus verlangt eine optimistische Restkosten&shy;sch√§tzung. Das bedeutet: Sie m√ºssen die Restkosten sch√§tzen, der Sch√§tzwert muss kleiner sein, als die tats√§chlichen Kosten sind. Trivial ist diese Bedingung erf√ºllt, wenn Sie die Restkosten immer auf <i>0</i> sch√§tzen.</p>
		<p>Der folgende theoretische Ansatz ist zwar in den Eigenschaften des <i>A*</i>-Algorithmus bewiesen, findet im Rahmen unserer Anwendung hier jedoch nur eine Randnotiz: Wenn es einen Pfad vom Start- zum Endknoten gibt, dann findet der <i>A*</i>-Algorithmus diesen, selbst wenn es sich um so genannte <i>unendliche</i> Graphen handelt. Unendliche Graphen sind bei impliziter Darstellung durchaus denkbar. In nicht-unendlichen Graphen terminiert der Algorithmus, wenn es keinen Pfad gibt.</p>
		<p>Die Monotonie-Bedingung verlangt, dass die Differenz der Restkosten-Sch√§tzwerte zweier Knoten kleiner ist als die tats√§chlichen Kosten der Pfade zwischen den beiden Knoten. Ist diese Bedingung erf√ºllt, hat der Algorithmus zu jedem Knoten, den er zur Expansion w√§hlt, bereits einen optimalen Pfad gefunden. Wenn Sie zwei <i>A*</i>-Algorithmen <i>A1</i> und <i>A2</i> mit den Restkosten&shy;sch√§tzungen <i>c1(x)</i> und <i>c2(x)</i> verwenden und <i>c(x)</i> die tats√§chlichen Restkosten bezeichnet, gilt f√ºr jeden Zustand <i>x</i> :</p>
		<pre><code>c1(x) < c2(x) < c(x)</code></pre>
		<p>F√ºr diese Bedingung gilt, dass <i>A2</i> besser als <i>A1</i> informiert ist. Das hat zur Folge, dass nach der Terminierung jeder Knoten, der von <i>A2</i> expandiert wurde, auch von <i>A1</i> expandiert wurde. <i>A1</i> hat also mindestens so viele Knoten wie <i>A2</i> expandiert. Es ist wichtig, die Zahl der Knoten und die Rechenzeit zu reduzieren.</p>
	</section>

	<section>
		<h2>Die Implementation des A*-Algorithmus</h2>
		<p>Nachdem Sie die Grundlagen des <i>A*</i>-Algorithmus kennen gelernt haben, wagen Sie sich an die Implementation heran. Wir stellen Ihnen hier eine Basis&shy;implementation vor, die leicht verst√§ndlich, aber nicht rechenzeit&shy;optimiert ist. Bei Punkten, an denen Sie eine Optimierung vornehmen k√∂nnen, weisen wir Sie an der entsprechenden Stelle darauf hin. Im Folgenden behandeln wir den Spezialfall, dass wir einen Pfad auf einer Spielwelt suchen, deren Karte aus einem regelm√§√üigen Schachbrett besteht. In einer Landkarte der Spielewelt speichern Sie, wie aufwendig es f√ºr die Spielfigur ist, sich dar√ºber zu bewegen.</p>
		<p>Die Implementation ist in der <i>AStar</i>-Klasse verpackt.</p>
		<pre><code>
class AStar
{
private:
	Position start, goal;

	int lowestOpen;
	int lowestCost;
	int nodesExpanded;

	int nOpen, nClosed;
	Node **open;
	Node **closed;

	Node *goalNode;
		</code></pre>
		<p>Die <i>Member</i>-Variablen der Klassen speichern au√üer dem Start- und Zielpunkt die <i>Open</i>- und <i>Closed</i>-Listen als Array. In einer optimierten <i>A*</i>-Suche w√ºrden Sie diese als <i>Priority Queues</i> speichern. In Priority Queues, die Sie als bin√§re B√§ume verwalten, geht es schneller, nach der <i>Node</i> (Knoten) mit den geringsten Kosten zu suchen. Au√üerdem speichern Sie den Index des voraus&shy;sichtlich besten Knotens, seine Kosten und einen Zeiger auf den Endknoten, sofern dieser gefunden wurde.</p>
		<p>F√ºr die Verwaltung der <i>Open</i>- und <i>Close</i>-Liste ben√∂tigen Sie Methoden, um Elemente einzuf√ºgen, zu suchen oder zu l√∂schen:</p>
		<pre><code>
void pushNode(Node **list,
	int *count, Node *node)
{
	list[(*count)++] = node;
}

int containsNode(Node **list,
	int count, Node *me)
{
	for(int i = 0; i &lt; count; i++)
		if(list[i]-&gt;p == me-&gt;p)
			return i;
	return -1;
}

void removeNode(Node **list,
	int *count, int me)
{
	list[me] = list[--(*count)];
}
		</code></pre>
		<p>F√ºr die Kosten&shy;berechnung oder -sch√§tzung ben√∂tigen Sie folgende Funktionen, wobei Sie die Sch√§tzung genauer untersuchen:</p>
		<pre><code>
// Kosten als Integerwerte !
#define COSTDIAGONAL 554
// sqrt(2) * 100000 / 255
#define COSTSTRAIGHT 392
// 100000 / 255
static const int travCost[8] =
{
	COSTDIAGONAL, COSTSTRAIGHT,
	COSTDIAGONAL, COSTSTRAIGHT,
	COSTSTRAIGHT, COSTDIAGONAL,
	COSTSTRAIGHT, COSTDIAGONAL
};

// Berechnung: d ist eine der 8
// Richtungen auf der Karte
// (NW,N,NO,W,O,SW,S,SO)

int traversalCost(Position &amp;a,
	Position &amp;b, int d)
{
	int c = (map[a.x()][a.y()] +
		map[b.x()][b.y()]) &gt;&gt; 1;
	return c * travCost[d];
}

// Sch√§tzung
int pathCostEstimate
	(Position &amp;s, Position &amp;g)
{
	return 0;
}
		</code></pre>
		<p>Beim Start der Suche l√∂schen Sie die <i>Open</i>- und <i>Close</i>-Liste und erzeugen einen Startknoten, den Sie in die <i>Open</i>-Liste eintragen. Au√üerdem speichern Sie den Zielknoten:</p>
		<pre><code>
void init(Position &amp;s, Position &amp;g)
{
	nOpen = nClosed = 0;
	Node *startNode = new Node();
	startNode-&gt;p = s;
	startNode-&gt;h =
	pathCostEstimate(s, g);
	startNode-&gt;f = startNode-&gt;h;
	startNode-&gt;pred = NULL;
	startNode-&gt;nPred = 0;
	goal = g;
	pushNode(open,&amp;nOpen,startNode);
	lowestOpen = nOpen - 1;
	lowestCost = startNode-&gt;f;
}
		</code></pre>
		<p>Nun k√∂nnen Sie mit der Suche und der Expansion der Knoten anfangen:</p>
		<pre><code>
int searchPath()
{
	//noch nodes in der open list?
	while(nOpen &gt; 0)
	{
		// beste node nehmen
		Node *node = open[lowestOpen];
		removeNode((Node**)open,
			&amp;nOpen, lowestOpen);
		findLowestCost();
		if (node-&gt;p == goal)
		{
			// ziel gefunden !
			goalNode = node;
			return node-&gt;nPred + 1;
		} else
		{
			expandNode(node);
			nodesExpanded ++;
		}
		pushNode(closed,&amp;nClosed,node);
	}
	// kein weg gefunden !
	return -1;
}
		</code></pre>
		<p>Die Expansion der Knoten ist das Kernst√ºck des <i>A*</i>-Algorithmus. Zun√§chst betrachten Sie jeden Nachbarknoten, der auf der Karte liegt und kein unbegehbares Spielfeld ist. Sie testen die Begehbarkeit in der If-Abfrage von <i>isValid()</i>:</p>
		<pre><code>
void expandNode(Node *node)
{
	for (int d = 0; d &lt; 8; d++)
{
	Position p = node-&gt;p.neighbour(d);
	if (isValid(p))
	{
		</code></pre>
		<p>Die Kosten bis zu dieser Node k√∂nnen Sie berechnen und in einer neuen Node speichern:</p>
		<pre><code>
int newCost = node-&gt;g +
	traversalCost(node-&gt;p, p, d);

Node *newNode = new Node(newCost,
	pathCostEstimate(p, goal),
	node, node-&gt;nPred + 1, p);

int io, ic, contained = 0, oldCost = -1;
		</code></pre>
		<p>Pr√ºfen Sie, ob die neue Node schon in einer Liste gespeichert ist:</p>
		<pre><code>
io = containsNode(open, nOpen, newNode);
ic = containsNode(closed, nClosed, newNode);

if (io != -1 || ic != -1)
{
	if (io != -1)
		oldCost = open[io]-&gt;g;
	else
		oldCost = closed[ic]-&gt;g;
}

if (oldCost != -1 &amp;&amp;
	oldCost <= newCost)
{
	delete newNode;
	continue;
}
else {
		</code></pre>
		<p>Nur einen neuen, besseren Weg zur aktuellen Node m√ºssen Sie speichern:</p>
		<pre><code>
	if (ic != -1)
		removeNode(closed,&amp;nClosed,ic);

	if (io != -1)
		removeNode(open, &amp;nOpen, io);

	pushNode(open,&amp;nOpen,newNode);
	findLowestCost();
}
		</code></pre>
		<p>Wenn ein Weg gefunden ist, √ºbertragen Sie diesen in ein Array aus der Elementen-<i>Position</i>. Dazu m√ºssen Sie r√ºckw√§rts den Weg vom Zielknoten aus verfolgen:</p>
		<pre><code>
int getPath(Position *p)
{
	Position *dst=
		&amp;p[goalNode-&gt;nPred];

	int length = goalNode-&gt;nPred + 1;
	Node *node = goalNode;
	while(1)
	{
		*dst = node-&gt;p;
		*dst--;
		if(node-&gt;pred != NULL)
			node = node-&gt;pred;
		else
			break;
	}
	return length;
}
		</code></pre>
		<figure class="large">
			<img src="assets/200108_2.jpg" width="808" height="827" alt="UNSER TESTPROGRAMM hat einen Pfad gefunden!">
			<figcaption><span>UNSER TESTPROGRAMM</span> hat einen Pfad gefunden!</figcaption>
		</figure>
		<p>Im Bild oben sehen Sie die Landkarte aus dem Testprogramm der Heft-CD. Helle Felder sind leichter passierbar, dunkle schwerer und schwarze Felder gar nicht. Die roten Pfeile markieren den Weg der Spielfigur. Die Felder, deren Nodes expandiert wurden, sind mit einem kleinen blauen K√§stchen gekennzeichnet.</p>
	</section>

		<section>
		<h2>Nachbarzust√§nde</h2>
		<p>Nach der Theorie und der Implementation des <i>A*</i>-Algorithmus k√∂nnen Sie die √Ñsthetik und die Performance der Wegsuche verbessern.</p>
		<p>Eine Karte aus regelm√§√üigen Feldern erleichtert die Wahl der Nachfolge&shy;knoten, die aus den vier direkt anliegenden Nachbarfeldern und den vier diagonal erreichbaren Feldern resultieren. Wenn Sie die Pfadsuche daran hindern wollen, ein Feld zu betreten, schlie√üen Sie dies in der Funktion <i>expandNode(...)</i> aus.</p>
		<p>In Computer&shy;spielen sichert dieses Verfahren, dass kein Fahrzeug √ºber Wasser f√§hrt und kein Schiff das Wasser verl√§sst. Wenn Sie einen beliebigen Graphen verwenden und kein regelm√§√üiges Gitter, ist es f√ºr die Rechenzeit wichtig, dass Sie die Adjazenz&shy;information (Nachbarschaft- oder Verbindungs&shy;information) f√ºr jeden Knoten speichern, denn Rechnen kostet Zeit und Geld.</p>
	</section>

	<section>
		<h2>Die Kostenfunktion</h2>
		<figure class="floatright">
			<img src="assets/200108_4.jpg" width="472" height="239" alt="DIE RESTKOSTENSCH√ÑTZUNG NULL und der euklidische Abstand im freien Gel√§nde im direkten Vergleich.">
			<figcaption><span>DIE RESTKOSTENSCH√ÑTZUNG NULL</span> und der euklidische Abstand im freien Gel√§nde im direkten Vergleich.</figcaption>
		</figure>
		<p>Die Kostenfunktion repr√§sentiert f√ºr einen Pfad vom Start- zum Endknoten den Wert, der minimiert werden soll. Das kann die Entfernung, Reisezeit oder verbrauchter Treibstoff sein. Sie k√∂nnen auch andere Faktoren einbringen. Denkbar w√§ren Aufschl√§ge f√ºr schlecht passierbares Terrain.</p>
		<p>Je nach Typ der Spielfigur (Aktortyp) in Ihrem Spiel sollten Sie die Aufschl√§ge variieren. Fahrzeuge bewegen sich auf Stra√üen deutlich schneller als querbeet, wohingegen der Unterschied f√ºr Infantrie nicht entscheidend ist. Die Kosten k√∂nnen von der Bewegungs&shy;richtung abh√§ngen. Bergauf ist teurer als bergab. Mit der Kostenfunktion beeinflussen Sie also nicht nur die Rechenzeit, sondern auch die √Ñsthetik des gefundenen Pfades und den Realismus. Die folgende einfache Kostenfunktion ber√ºcksichtigt die Richtung der Bewegung nicht, daf√ºr das Terrain mit Start- und Endposition:</p>
		<pre><code>
int traversalCost(Position &amp;a,
	Position &amp;b, int d)
{
	int c =(map[a.x()][a.y()] +
		map[b.x()][b.y()]) &gt;&gt; 1;

	return c * travCost[d];
}
		</code></pre>
	</section>

	<section>
		<h2>Die Kostensch√§tzung</h2>
		<p>Die Sch√§tzung der Restkosten ist ein weiterer zeitkritischer Punkt bei der Pfadsuche mit dem <i>A*</i>-Algorithmus. Die Restkosten optimistisch auf Null zu sch√§tzen, ist an hier optimal: Die Rechenzeit ist auch Null.</p>
		<figure class="large">
			<img src="assets/200108_3.jpg" width="808" height="827" alt="DIE OPTIMISTISCHE Restkostensch√§tzung Null expandiert zu viele Knoten.">
			<figcaption><span>DIE OPTIMISTISCHE</span> Restkostensch√§tzung Null expandiert zu viele Knoten.</figcaption>
		</figure>
		<p>In Folge m√ºssen Sie daf√ºr sehr viel mehr Knoten expandieren als bei einer etwas sinnvolleren Sch√§tzung: Verwenden Sie besser den euklidischen Abstand, den sie mit den minimalen Bewegungs&shy;kosten multiplizieren. Diese Sch√§tzung liefert schon deutlich bessere Ergebnisse.</p>
		<p>Da der Abstand nicht k√ºrzer sein kann als die Fluglinie, ist das auch eine optimistische Sch√§tzung. Eine einfache Kostensch√§tz&shy;funktion ist der euklidische Abstand zweier Knoten unter Ber√ºcksichtung der Begehbarkeit der Landschaft:</p>
		<pre><code>
int pathCostEstimate(Position &amp;s, Position &amp;g)
{
	int c = (map[s.x() ][s.y()] +
		map[g.x()][g.y()]) &gt;&gt; 1;

	return max(abs(s.x()- g.x()),
		abs(s.y() - g.y())) *
		COSTSTRAIGHT * c;

	// triviale variante
	return 0;
}
		</code></pre>
		<p>Anhand der Zahl der expandierten Knoten in den beiden vorigen Bildern sehen Sie die Auswirkungen verschiedener Kosten&shy;sch√§tzungen. Diese beweisen, wie unter&shy;schiedlich die Zahl der expandierten Knoten sein kann.</p>
	</section>

	<section>
		<h2>Schw√§chen des A*-Algorithmus</h2>
		<p>Der <i>A*</i>-Algorithmus kann auf gro√üen Spielkarten sehr viel Speicher verbrauchen, wenn Hunderte oder Tausende von Nodes expandiert werden. Er nimmt die CPU stark in Beschlag.</p>
		<p>Besonders schlecht ist der <i>A*</i>-Algorithmus in F√§llen, in denen kein Weg existiert, da er dann jede vom Startknoten aus erreichbare Position expandiert. Um in diesem Fall Rechenzeit zu sparen, analysieren Sie vorab Ihre Spielfeldkarte. Dies k√∂nnen Sie manuell oder algorithmisch tun. Speichern Sie das Ergebnis, wenn es √ºberhaupt einen Pfad zwischen zwei Feldern gibt.</p>
		<p>Daneben gibt es einige Ansatzpunkte den <i>A*</i>-Algorithmus schneller zu machen. Sie k√∂nnen die Geschwindig&shy;keit durch bessere Expansion der Knoten und der Restkosten&shy;sch√§tzung erh√∂hen. Die √Ñsthetik k√∂nnen Sie durch Ausschlie√üen von Knoten, die Gl√§ttung des resultierenden Pfades oder Verwendung von Splines f√ºr die tats√§chlichen Wege verbessern.</p>
	</section>

	<footer>
		<p>Erhard Thomas</p>
		<p>¬© 2001 WEKA Computerzeitschriften Verlag</p>
		<p class="footnote"><b>Literatur:</b></p>
		<p class="footnote">Russel, Stuart und Norvig, Peter, Artificial Intelligence: A Modern Approach, Prentice Hall, 1995</p>
		<p class="footnote">Nilsson, Nils J., Artificial Intelligence: A New Synthesis. Morgan Kaufmann, 1998</p>
	</footer>
	</article>

	<nav class="pagenav">
		<a rel="prev" href="200107.html">7/2001</a>
		<a href="index.html">Inhalt</a>
		<a rel="next" href="200109.html">9/2001</a>
	</nav>
</body>
