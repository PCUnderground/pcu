<!DOCTYPE html>
<html lang="de">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="style.css">
	<title>Mathematik ausgereizt (PC Underground, PC Magazin 3/2001)</title>
</head>
<body>
	<div class="credits">
		<h2>Dieser Artikel erschien erstmals im PC&nbsp;Magazin&nbsp;3/2001. Die Wieder&shy;ver√∂ffentlichung erfolgt mit freundlicher Genehmigung der <a rel="external nofollow noreferrer" href="https://www.weka-media-publishing.de">WEKA&nbsp;Media&nbsp;Publishing&nbsp;GmbH</a>.</h2>
	</div>

	<nav class="pagenav">
		<a rel="prev" href="200102.html">2/2001</a>
		<a href="index.html">Inhalt</a>
		<a rel="next" href="200104.html">4/2001</a>
	</nav>

	<article>
	<header>
		<h2>B√©zier- und Spline-Fl√§chen</h2>
		<h1>Mathematik <span class="highlight">ausgereizt</span></h1>
		<p class="summary">Hinter den reizenden Kurven virtueller Gestalten und hinter malerischen, <span class="highlight">bl√ºhenden Landschaften</span> verbirgt sich simple Mathematik.</p>
	</header>

	<section>
		<h3>Carsten Dachsbacher</h3>
		<p>Mit dem mathematischen Handwerkszeug aus PC Underground 01/01 (ab S. 258) zaubern Sie B√©zier- und Spline-Fl√§chen auf Ihren Bildschirm. Diese Art der Repr√§sentation von 3D-Modellen findet man in Computer&shy;spielen: in Torb√∂gen, Brunnen&shy;sch√§chten, S√§ulen oder Landschaften. Sie k√∂nnen damit auch Modelle aus gew√∂lbten Fl√§chen pr√§sentieren.</p>
	</section>

	<aside>
		<h2>QUELLTEXTE</h2>
		<div>Die Quelltexte zu diesem Artikel finden Sie in der Datei  <a href="200103.zip">üíæ 200103.zip</a>.</div>
	</aside>

	<section>
		<h2>Tensor-Produkt-Fl√§chen</h2>
		<p>Aus parametrischen Kurven k√∂nnen Sie mit dem Tensor-Produkt-Ansatz Fl√§chen zusammensetzen. Dazu ben√∂tigen Sie zwei Kurven:
		<img class="math" src="assets/200103_9.png" width="152" height="110" alt="Zwei Kurven"></p>
		<p>Der Tensor-Produkt-Ansatz fasst beide Kurven unter einer Doppelsumme zusammen:
		<img class="math" src="assets/200103_10.png" width="219" height="57" alt="Doppelsumme"></p>
		<p>Wenn Sie die Terme in der obigen Formel anders klammern, l√§sst sich die Tensor-Produkt-Fl√§che als Kurve auf einer Kurve deuten. Sie berechnen den Funktionswert der einen Kurve (innere Klammer) und verwenden das Ergebnis als St√ºtzpunkt f√ºr die zweite Kurve (√§u√üere Summe).
		<img class="math" src="assets/200103_11.png" width="233" height="181" alt="Tensor-Produkt-Fl√§che"></p>
		<p>Der Term <i>dij</i> fasst die St√ºtzpunkte der Tensor-Produkt-Fl√§che zusammen. Allerdings haben Sie f√ºr die Fl√§che nicht <i>(m+n+2)</i>, sondern <i>(m+1)*(n+1)</i> St√ºtzpunkte. Das gibt Ihnen mehr Freiheit, die Fl√§che zu modellieren.</p>
		<p>Welche Basis&shy;funktionen (B√©zier oder Spline) Sie verwenden, ist aus mathematischer Sicht nicht festgelegt. Praktiker kombinieren immer zwei Basis&shy;funktionen gleichen Typs.</p>
	</section>

	<section>
		<h2>TP-B√©zier-Patch</h2>
		<p>Von einem TP-B√©zier-Patch spricht man, wenn Sie f√ºr beide Basis&shy;funktionen B√©zier-Kurven w√§hlen. Diese Variante besitzt Eigenschaften, die Sie beim Modellieren und beim Rendering nutzen k√∂nnen.</p>
		<p>TP-B√©zier-Patches und andere TP-Fl√§chen haben ein zwei&shy;dimensionales Parameter&shy;gebiet. Ein Punkt auf der Fl√§che h√§ngt von zwei Koordinaten ab. Diese und das Kontroll&shy;polygonnetz definieren die Fl√§che.</p>
		<p>Der TP-B√©zier-Patch hat von den zwei&shy;dimensionalen B√©zier-Kurven die Eigenschaft <i>konvexe H√ºlle</i> geerbt. Das bedeutet, dass die konvexe H√ºlle mit allen Knoten des Kontrollnetzes auch den TP-B√©zier-Patch enth√§lt. Wie sich die Kurve in den Start- und Endpunkten tangentiell an das Kontroll&shy;polygon legt, so verh√§lt sich die Fl√§che an den Eckpunkten des Kontrollnetzes. Anders ausgedr√ºckt: Bei B√©zier-Kurven endet die Kurve im ersten und letzten Kontrollpunkt und verl√§uft tangentiell am Kontroll&shy;polygon. Ein TP-B√©zier-Patch verl√§uft durch die Eckpunkte des Kontrollnetzes und dort tangentiell am Kontrollnetz. Daraus ergibt sich die Normale der Fl√§che an <i>b00</i>:
		<img class="math" src="assets/200103_12.png" width="192" height="38" alt="Normale"></p>
		<p>Die wichtigste Eigenschaft f√ºr den Einsatz der B√©zier-Patches in der 3D-Grafik ist die Affine Invarianz. Eine affine Transformation setzt sich aus Rotation und Translation (Verschiebung) zusammen. Mit dieser Eigenschaft k√∂nnen Sie die Fl√§che √ºber die Punkte des Kontrollnetzes rotieren und verschieben und mit den gleichen Algorithmen neu auswerten. W√§re diese Eigenschaft nicht gegeben, w√ºrde die Fl√§che bei solchen Aktionen ihre Gestalt ver√§ndern.</p>
		<p>Eine Eigenschaft der Kurven √ºbertr√§gt sich allerdings nicht auf den TP-B√©zier-Patch: die Variation Diminishing Property. Die parametrische Fl√§che kann daher mehr W√∂lbungen oder Beulen aufweisen als die Basis&shy;funktionen.</p>
		<figure class="floatright">
			<img src="assets/200103_1.png" width="538" height="288" alt="DAS PARAMETERGEBIET und das Kontrollpolygon eines TP-B√©zier-Patches">
			<figcaption><span>DAS PARAMETERGEBIET</span> und das Kontrollpolygon eines TP-B√©zier-Patches</figcaption>
		</figure>
		<p>Die Algorithmen, die Sie bereits f√ºr den Kurvenfall kennengelernt haben, wie de Casteljau-Algorithmen zum Beispiel Unterteilung, Graderh√∂hung und die Konstruktion stetiger √úberg√§nge, k√∂nnen Sie direkt von den Kurven auf die Fl√§chen √ºbertragen. Dies f√ºhrt Ihnen unser Beitrag anhand des de Casteljau-Algorithmus vor. Dieser verwendet die Darstellung eines TP-B√©zier-Patches als Kurve auf einer Kurve. Es bietet sich also an, zuerst die eine Kurve (die innere Klammer in der obigen Formel) mit dem de-Casteljau-Algorithmus auszuwerten. Damit erhalten Sie die St√ºtzpunkte der zweiten Kurve, die Sie auch wieder auswerten. Wie Sie aus der vorigen Definition der TP-Fl√§chen entnehmen, liefert jede Reihenfolge der Auswertungen, also <i>u/v</i> oder <i>v/u</i>, dasselbe Ergebnis. Eine Darstellung der Auswertungs&shy;pyramiden des de-Casteljau-Algorithmus bei einem bikubischen TP-B√©zier-Patch (in beiden Basis&shy;funktionen kommen Terme bis zur dritten Potenz vor) finden Sie im Bild unten.</p>
	</section>

	<section>
		<h2>3x3-TP-B√©zier-Patch</h2>
		<p>Mit bikubischen TP-B√©zier-Patches lassen sich viele interessante Modelle konstruieren. Diese setzen sich meist aus mehreren Patches zusammen; dadurch k√∂nnen Sie 3D-Modelle mit zahlreichen Details versehen. Sie werten aus Basis&shy;funktionen ‚Äì durch geeignete Verfahren und unter Ber√ºck&shy;sichtigung eines Spezialfalls ‚Äì noch schneller aus.</p>
		<p>Der Spezialfall hier ist zum einen, dass Sie bikubische TP-B√©zier-Patches betrachten, und zum anderen, dass Sie darauf 81 regelm√§√üig verteilte Punkte auswerten wollen ‚Äì also die Fl√§che zu einem 9 x 9-Polygongitter tessellieren. Das heisst, Sie wandeln die Fl√§che in Polygone, zumeist Dreiecke, um.</p>
		<p>Dazu nutzen Sie <i>Central Differencing</i>: Die Randkurven einer B√©zier-Fl√§che sind B√©zier-Kurven. Diese Randkurven k√∂nnen Sie sukzessive am Mittelpunkt und √ºber die Fl√§che hinweg unterteilen. So berechnen Sie den Mittelpunkt einer B√©zier-Kurve: Als erstes betrachten Sie eine Randkurve. Diese schreiben Sie als Taylor-Reihe. Dabei handelt es sich um die Darstellung einer Funktion durch eine Summe √ºber ihre Ableitungen. In der folgenden Formel ist <i>Fi(u)</i> die i-te Ableitung der Funktion. Der Wert der Formel ist ein Punkt in der N√§he von <i>u</i>, also <i>du</i> entfernt.
		<img class="math" src="assets/200103_13.png" width="202" height="66" alt="Summe der Ableitungen"></p>
		<p>Da Sie kubische Basis&shy;funktionen betrachten, k√∂nnen Sie diese (mit den zun√§chst unbekannten Parametern <i>a, b,</i> <i>c, d</i>) und ihre Ableitungen wie folgt aufschreiben:
		<img class="math" src="assets/200103_14.png" width="185" height="164" alt="Ableitungen der kubischen Basisfunktionen"></p>
		<p>Ab der vierten Ableitung sind bei einer kubischen Funktion alle Ableitungen gleich Null. Weil die Taylor-Reihe keine Summe bis unendlich enth√§lt, l√§sst sie sich leicht aufschreiben:
		<img class="math" src="assets/200103_15.png" width="231" height="96" alt="Taylor-Reihe"></p>
		<p>F√ºr Punkte, die in der anderen Richtung von <i>u</i> liegen, erhalten Sie folgende Formel:
		<img class="math" src="assets/200103_16.png" width="238" height="90" alt="Taylor-Reihe"></p>
		<p>Wenn Sie die letzen beiden Gleichungen addieren, erhalten Sie das vielver&shy;sprechende Ergebnis:
		<img class="math" src="assets/200103_17.png" width="297" height="36" alt="Ergbnis">
		welche nach <i>F(u)</i> aufgel√∂st:
		<img class="math" src="assets/200103_18.png" width="297" height="55" alt="nach F(u) aufgel√∂st">
		ergibt.</p>
		<p>Dabei halten Sie das Ziel im Auge, eine B√©zier-Kurve in der Mitte zu unterteilen. So erhalten Sie die ben√∂tigte Menge an St√ºtzpunkten entlang der B√©zier-Kurve. Der Parameter <i>u</i> l√§uft von <i>0</i> bis <i>1</i>, die Mitte der Kurve ist bei <i>du = 0.5</i>.
		<img class="math" src="assets/200103_19.png" width="260" height="72" alt="Mitte der Kurve">
		Die eingesetzten Werte sind f√ºr den ersten Unterteilungs&shy;schritt.</p>
		<p><i>F(0)</i> und <i>F(1)</i> sind zwei Eckpunkte des Kontrollnetzes. Sie ben√∂tigen die zweite Ableitung in der Mitte einer B√©zier-Kurve. Die von <i>F(u)</i> hergeleitete Formel hilft Ihnen weiter, wenn Sie darin <i>F(u)</i> durch <i>F‚Äô‚Äô(u)</i> ersetzen:
		<img class="math" src="assets/200103_20.png" width="261" height="112" alt="Zweite Ableitung"></p>
		<figure class="floatright">
			<img src="assets/200103_2.png" width="450" height="422" alt="EINE DOPPELTE ANWENDUNG des de-Casteljau-Algorithmus f√ºhrt zum gew√ºnschten Punkt.">
			<figcaption><span>EINE DOPPELTE ANWENDUNG</span> des de-Casteljau-Algorithmus f√ºhrt zum gew√ºnschten Punkt.</figcaption>
		</figure>
		<p>Den letzen Term k√∂nnen Sie vernach&shy;l√§ssigen, da die vierte Ableitung immer gleich Null ist. In unserem Beispiel erhalten Sie:
		<img class="math" src="assets/200103_21.png" width="171" height="52" alt="Zweite Ableitung"></p>
		<p>Die zweiten Ableitungen an den Stellen <i>u=0</i> und <i>u=1</i> k√∂nnen Sie direkt berechnen. Dazu schreiben Sie die Summenform der B√©zier-Kurve aus und leiten diese ab. Damit erhalten Sie folgende Resultate:
		<img class="math" src="assets/200103_22.png" width="247" height="207" alt="Summenform"></p>
		<p>Nun haben Sie alle Berechnungen erledigt, mit denen Sie eine B√©zier-Kurve sukzessiv unterteilen. Alle vorkommenden Werte (<i>F(0), F(1)....)</i> ersetzen Sie in den weiteren Rechen&shy;schritten durch die entsprechenden Zwischen&shy;ergebnisse: Wenn Sie eine Kurve unterteilt haben, erhalten Sie zwei neue, deren einer End- oder Startpunkt das Resultat der obigen Berechnung ist.</p>
		<p>Doch woher bekommen Sie die zweite Ableitung, wenn Sie nicht mehr entlang einer Randkurve, sondern √ºber die Fl√§che unterteilen? Das entspricht der Unterteilung einer Kurve im anderen Parameter. Dabei hilft Ihnen folgende schon bekannte Gleichung:
		<img class="math" src="assets/200103_23.png" width="292" height="108" alt="Unterteilung der Kurve"></p>
		<p>Sie k√∂nnen also die zweite partielle Ableitung in <i>v</i>-Richtung auf einer <i>u</i>-Randkurve berechnen, wenn Sie den Wert <i>F<sub>uuvv</sub></i> kennen. <i>F<sub>uuvv</sub></i> bedeutet die zweite Ableitung der Fl√§che in <i>u-</i> und <i>v</i>-Richtung. Auch diese erhalten Sie durch Mittelung zweier Werte an den Kurven Start- oder Endpunkten, welche die folgende Formel ausweist:
		<img class="math" src="assets/200103_24.png" width="241" height="86" alt="Mittelung"></p>
		<p>Es gen√ºgt also, den Wert an den Eckpunkten zu kennen, um den ersten Berechnungs&shy;schritt zu starten. Diese Werte m√ºssen Sie direkt ausrechnen:
		<img class="math" src="assets/200103_25.png" width="260" height="118" alt="Eckpunkte"></p>
		<p>In die untere Gleichung setzen Sie die Ableitungen der Bernstein-Polynome ein:
		<img class="math" src="assets/200103_26.png" width="144" height="131" alt="Bernstein-Polynome"></p>
		<p>Die Initialisierung einer Unterteilung berechet folgende drei Werte:
		<img class="math" src="assets/200103_27.png" width="261" height="166" alt="Unterteilung"></p>
		<p>Sie unterteilen diese mit jedem Rechenschritt folgenderma√üen
		<img class="math" src="assets/200103_28.png" width="298" height="326" alt="Unterteilung"></p>
		<figure class="floatright">
			<img src="assets/200103_3.png" width="703" height="239" alt="ZUERST UNTERTEILEN SIE die Randkurven, anschlie√üend √ºber die Fl√§che hinweg.">
			<figcaption><span>ZUERST UNTERTEILEN SIE</span> die Randkurven, anschlie√üend √ºber die Fl√§che hinweg.</figcaption>
		</figure>
		<p>Alles zusammen&shy;genommen, k√∂nnen Sie im Vergleich zum de-Casteljau-Algorithmus die Anzahl der n√∂tigen Additionen und Multi&shy;plikationen mehr als halbieren, was den Aufwand in einer zeitkritischen Anwendung rechtfertigt. Einen Vergleich und eine genaue Auswertung des de-Casteljau-Algorithmus und des <i>Central Differencing</i> k√∂nnen Sie im Artikel <i><a href="https://www.gamasutra.com/features/19991027/deloura_01.htm" rel="external nofollow noreferrer">An In-Depth Look at Bicubic B√©zier Surfaces</a></i> von Mark A. DeLoura abrufen.</p>
		<p>Auch f√ºr 4 x 4-TP-B√©zier-Fl√§chen bietet das Internet Informationen. Haim Barad beschreibt im Artikel <i><a href="https://www.gamasutra.com/features/20000317/barad_01.htm" rel="external nofollow noreferrer">Tessellation of 4x4 B√©zier Patches for the Intel Pentium III Processor</a></i> wie Sie solche B√©zier-Patches mit Pentium-3-Befehlen effizient tessellieren k√∂nnen.</p>
	</section>

	<section>
		<h2>Andere Tensor-Produkt-Fl√§chen</h2>
		<figure class="floatright">
			<img src="assets/200103_4.png" width="684" height="330" alt="LINKS SEHEN SIE EINE herk√∂mmliche Spline-Fl√§che, rechts eine hierarchische mit aufgesetztem lokalen Detail.">
			<figcaption><span>LINKS SEHEN SIE EINE</span> herk√∂mmliche Spline-Fl√§che, rechts eine hierarchische mit aufgesetztem lokalen Detail.</figcaption>
		</figure>
		<p>Mit jeder Basisfunktion k√∂nnen Sie Tensor-Produkt-Fl√§chen erzeugen (vgl. PC Underground 1/01, ab S. 258). Genauso wie bei den B√©zier-Fl√§chen k√∂nnen Sie alle Eigenschaften, bis auf Variation Diminishing, von den Kurven auf die Fl√§chen √ºbertragen. Wenn Sie in einem kleinen Teil einer Spline-Fl√§che mehr Details modellieren wollen, ben√∂tigen Sie in jeder Randkurve mehrere St√ºtzpunkte.</p>
		<p>Angenehmer w√§re eine L√∂sung wie rechts im Bild, bei der nur der Bereich mit lokalem Detail auch mehr St√ºtzpunkte enth√§lt. Ein L√∂sungsansatz dazu sind die hierarchischen Spline-Fl√§chen:</p>
		<p><i>F1(u,v)</i> ist die grobe Fl√§che, <i>F2(u,v)</i> die kleine, detailreiche auf <i>F1</i> aufgesetzte Fl√§che.</p>
	</section>

	<section>
		<h2>Parametrische Fl√§chen trimmen</h2>
		<figure class="floatright">
			<img src="assets/200103_5.png" width="470" height="233" alt="NEBEN DER MATHEMATISCHEN Darstellung des Parameter&shy;gebiets sehen Sie in Blau die getrimmte Fl√§che.">
			<figcaption><span>NEBEN DER MATHEMATISCHEN</span> Darstellung des Parameter&shy;gebiets sehen Sie in Blau die getrimmte Fl√§che.</figcaption>
		</figure>
		<p>Nicht immer wollen Sie, dass das ganze Parameter&shy;gebiet verwendet wird, sondern Sie wollen Ihre parametrische Fl√§che zurecht&shy;schneiden. Dabei spricht man vom Trimmen der Fl√§che. Bei der Tessellierung l√§sst sich das nicht direkt umsetzen, aber zur direkten Berechnung k√∂nnen Sie das nachfolgende Verfahren nutzen. Um eine Fl√§che zu trimmen, verwenden Sie im Parameter&shy;gebiet eine geschlossene Kurve und ein Fl√§chenschema. Ermitteln Sie f√ºr jedes Koordinaten&shy;paar <i>(u,v)</i>, ob es innerhalb oder au√üerhalb des getrimmten Bereiches liegt. Die geschlossenen Kurven markieren den getrimmten Bereich. Dazu bedienen Sie sich des so genannten <i>Odd-Even</i>-Tests: Vom Punkt <i>(u,v)</i> im Parameter&shy;gebiet ausgehend verfolgen Sie eine Halbgerade in eine beliebige Richtung. Nun z√§hlen Sie die Anzahl der Schnittpunkte der Halbgerade mit den gegebenen Kurven. Bei einer ungeraden Anzahl von Schnittpunkten liegt <i>(u,v)</i> im getrimmten Bereich, sonst au√üerhalb.</p>
		<figure class="large">
			<img src="assets/200103_6.png" width="585" height="329" alt="DER ODD-EVEN-TEST verr√§t Ihnen, wo sich der Punkt befindet.">
			<figcaption><span>DER ODD-EVEN-TEST</span> verr√§t Ihnen, wo sich der Punkt befindet.</figcaption>
		</figure>
		<p>Einen interessanten Artikel √ºber NURBS (Non-Uniformal Rational B-Splines, eine Variante von Splines) finden Sie bei <a href="https://developer.intel.com/software/idap/games/nurbs/index.htm" rel="external nofollow noreferrer">Intel</a>.</p>
	</section>

	<section>
		<h2>Patches rendern</h2>
		<p>Die besten Algorithmen, um Fl√§chen zu berechnen, nutzen Ihnen nichts, wenn Sie diese nicht darstellen k√∂nnen. Mit OpenGL bringen Sie mit relativ wenigen Befehlen die Patches auf den Bildschirm. Einen einfachen Start, mit dem Sie OpenGL im Fenster- und im Vollbild-Modus in beliebiger Aufl√∂sung und Farbtiefe verwenden k√∂nnen, finden Sie im Quellcode auf der Heft-CD im Verzeichnis unter <i>PC Underground</i>.</p>
		<p>Um die parametrischen Fl√§chen zu rendern, positionieren Sie zuerst den Betrachter. Diese Information speichert OpenGL in der Projektions&shy;matrix:</p>
		<pre><code>
glMatrixMode(GL_PROJECTION);
glLoadIdentity();
gluPerspective(45.0f, aspectratio, 1.01f, 1000.0f);
glTranslatef(0.0f,0.0f,-120.0f);
		</code></pre>
		<p>Die Transformationen der Polygon-Daten speichern Sie in der <i>Modelview</i>-Matrix:</p>
		<pre><code>
glMatrixMode(GL_MODELVIEW);
glLoadIdentity();
		</code></pre>
		<p>Hierbei verf√ºgen Sie √ºber folgende Befehle, um Polygone im Raum um eine Achse zu drehen, zu verschieben (Translation) oder in der Gr√∂√üe zu ver√§ndern (Skalierung):</p>
		<pre><code>
void glRotatef(GLfloat winkel, GLfloat x,GLfloat y,GLfloat z);
void glTranslatef(GLfloat x, GLfloat y, GLfloat z);
void glScalef(GLfloat x, GLfloat y, GLfloat z);
		</code></pre>
		<p>Nachdem Sie diese Befehle mit angepassten Parametern ausgef√ºhrt haben ‚Äì eine Implementation k√∂nnen Sie unserem Beispiel&shy;programm entnehmen ‚Äì k√∂nnen Sie die Polygone zeichnen. Zun√§chst bestimmen Sie die Zeichenfarbe:</p>
		<pre><code>
glColor3f(GLfloat rot, GLfloat green, GLfloat blue);
		</code></pre>
		<p>So k√∂nnen Sie Dreiecke, die Sie durch das Tessellieren erhalten haben, auf verschiede Arten ausgeben. Geben Sie einzelne Dreiecke aus, indem Sie deren Eckpunkte angeben:</p>
		<pre><code>
glBegin(GL_TRIANGLES);
for(alle Dreiecke)
{
	glVertex3f(x1, y1, z1);
	glVertex3f(x2, y2, z2);
	glVertex3f(x3, y3, z3);
}
glEnd();
		</code></pre>
		<figure class="floatright">
			<img src="assets/200103_8.png" width="393" height="171" alt="POLYGONE K√ñNNEN SIE mit OpenGL auf verschiedene Arten ausgeben.">
			<figcaption><span>POLYGONE K√ñNNEN SIE</span> mit OpenGL auf verschiedene Arten ausgeben.</figcaption>
		</figure>
		<p>Alternativ k√∂nnen Sie Triangle Strips zeichnen. Dabei nutzen Sie, dass Sie einen Streifen von Dreiecken rendern, bei dem sich zwei aufeinander folgende Dreiecke eine Kante teilen. Mit dieser Variante erreichen Sie eine deutlich h√∂here Performance, weil weniger Daten an OpenGL √ºbertragen werden und OpenGL weniger Aufwand betreiben muss.</p>
		<p>Die Anzahl der Dreiecke, die Sie bei der Tessellierung erzeugen, ist nicht nur f√ºr die Frame-Rate beim Rendern interessant. Je n√§her eine Fl√§che am Betrachter ist, desto feiner m√ºssen Sie tessellieren, damit sie glatt wirkt. Fl√§chen, die nur klein am Bildschirm zu sehen sind, lassen sich nur grob tessellieren. Wie Sie sehen. Besteht ein 3D-Modell aus parametrischen Fl√§chen, ben√∂tigen Sie ‚Äì anders als bei polygonalen Modellen ‚Äì nur eine Repr√§sentation, um verschiedene Detailstufen zu berechnen.</p>
	</section>

	<section>
		<h2>Parametrische Fl√§chen texturieren</h2>
		<figure class="floatright">
			<img src="assets/200103_7.png" width="640" height="399" alt="EINE TEXTUR WIRD auf ein Dreieck gespannt.">
			<figcaption><span>EINE TEXTUR WIRD</span> auf ein Dreieck gespannt.</figcaption>
		</figure>
		<p>Eine Textur ist ein zwei&shy;dimensionales Muster, das Sie auf 3D-Objekte oder Fl√§chen kleben. Nutzen Sie die beiden Parameter <i>u</i> und <i>v</i> aus Ihrem zwei&shy;dimensionalen Parameter&shy;gebiet, um parametrische Fl√§chen zu texturieren. Die Textur&shy;koordinaten in OpenGL geben Sie f√ºr jeden Vertex an:</p>
		<pre><code>
glTexCoord2d(u, v);
glVertex3f(x, y, z);
		</code></pre>
		<p>Vorher laden Sie eine entsprechende Textur und √ºbergeben sie an OpenGL. Verwenden Sie die Funktionen aus der <i>glaux</i>-Library (Datei: <i>glaux.h</i>). Mit wenigen Codezeilen k√∂nnen Sie eine Textur laden und f√ºr OpenGL verwenden, wobei Sie zuerst eine <i>bmp</i>-Datei in den Speicher laden:</p>
		<pre><code>
AUX_RGBImageRec *texture;
texture = auxDIBImageLoad("texture.bmp");
		</code></pre>
		<p>Lassen Sie sich von OpenGL eine ID geben, mit der Sie Ihre Textur bezeichnen wollen:</p>
		<pre><code>
GLint textureID;
glGenTextures(1, &amp;textureID);
		</code></pre>
		<p>Schalten Sie OpenGL ein:</p>
		<pre><code>
glBindTexture(GL_TEXTURE_2D, textureID);
		</code></pre>
		<p>Stellen Sie die Texturfilter ein: wie die Textur gerendert werden soll, wenn sie gedehnt oder gestaucht wird:</p>
		<pre><code>
glTexParameteri(GL_TEXTURE_2D,
	GL_TEXTURE_MAG_FILTER, GL_LINEAR);
glTexParameteri(GL_TEXTURE_2D,
	GL_TEXTURE_MIN_FILTER, GL_LINEAR);
		</code></pre>
		<p>Im n√§chsten Arbeitsschritt √ºbergeben Sie OpenGL die Texturdaten:</p>
		<pre><code>
glTexImage2D(GL_TEXTURE_2D, 0, 3,
	texture-&gt;sizeX,
	texture-&gt;sizeY,
	0, GL_RGB, GL_UNSIGNED_BYTE,
	texture-&gt;data);
		</code></pre>
		<p>und k√∂nnen den jetzt nicht mehr ben√∂tigten Speicher wieder freigeben:</p>
		<pre><code>
free(texture-&gt;data);
free(texture);
		</code></pre>
		<p>Mit folgenden Befehlen schalten Sie das Texturieren an oder aus:</p>
		<pre><code>
glEnable(GL_TEXTURE_2D);
glDisable(GL_TEXTURE_2D);
		</code></pre>
		<p>Bei Texturen k√∂nnen Sie zu jedem Texel (ein Bildpunkt der Textur) nicht nur die Farbe, sondern auch einen Alphawert angeben. Der Alphawert steht f√ºr die <i>Opakheit</i> (Sichtbarkeit als Gegensatz zur Transparenz) eines Texels: Der Wert <i>(1.0)</i> steht f√ºr nicht transparent, <i>0.0</i> f√ºr durchsichtig. Sie k√∂nnen eine Fl√§che mit einer Textur vollst√§ndig √ºberziehen und auf dieser die unsichtbaren Teile mit dem entsprechenden Alphawert markieren. Weisen Sie OpenGL an, diese Teile der Fl√§che nicht zu zeichnen. Dabei hilft Ihnen der Alpha-Test, den Sie wie folgt aktivieren und verwenden:</p>
		<pre><code>
glEnable(GL_ALPHA_TEST);
glAlphaFunc(GL_GREATER);
		</code></pre>
		<p>Damit verf√ºgen Sie √ºber eine Reihe von Methoden, um parametrische Fl√§chen zu berechnen und einzusetzen. In Computer&shy;spielen k√∂nnen Sie den Einsatz dieser Verfahren beobachten.</p>
	</section>

	<footer>
		<p>Erhard Thomas</p>
		<p>¬© 2001 WEKA Computerzeitschriften Verlag</p>
		<p class="footnote"><b>Literatur:</b></p>
		<p class="footnote">Gerald Farin, Curvers and Surfaces for Computer Aided Geometric Design, Academic Press, ISBN 0-12-249054-1</p>
		<p class="footnote">Brian Sharp, Implementing Curved Surface Geometry und Optimizing Curved Surface Geometry, Game Developer Magazine</p>
		<p class="footnote">Alan und Mark Watt, Advanced Animation and Rendering Techniques: Theory and Practice, New York: ACM Press, 1992</p>
		<p class="footnote">J.H. Clark, A Fast Scan-Line Algorithm for Rendering Parametric Surfaces, Computer Graphics Vol. 13 No.2: pp. 289-99.</p>
	</footer>
	</article>

	<nav class="pagenav">
		<a rel="prev" href="200102.html">2/2001</a>
		<a href="index.html">Inhalt</a>
		<a rel="next" href="200104.html">4/2001</a>
	</nav>
</body>
